<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.5.4\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.Titan.0.5.4\lib\Weaver.Titan.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Query" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using Fabric.Domain;
using Weaver.Core.Query;

namespace Fabric.Infrastructure.Weaver {

<#
IList<string> verts = SchemaHelper.GetVertices();

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	
	if ( vertex.IsRoot ) { continue; }

	IList<SchemaHelperVertexEdge> vertexEdges = hn.GetEdges();
	string vertexType = (vertex.IsBaseClass ? "T" : vertex.Name);
	string baseType = (vertex.BaseVertex == null ? "Domain" : vertex.BaseVertex.Name);

	if ( vertex.IsBaseClass ) {
#>
	/*================================================================================================*/
	public abstract class <#= vertex.Name #>Builder<<#= vertexType #>> : DomainBuilder<T> where T : class, IVertex, new() {

<#
	}
	else {
#>
	/*================================================================================================*/
	public class <#= vertex.Name #>Builder : <#= baseType #>Builder<<#= vertexType #>> {

<#
	} //end abstract condition

	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		if ( hr.TargetVertexType == "Root" ) {
			continue;
		}
		
		string type = "IWeaverVarAlias<"+hr.TargetVertexType+">";
		
		if ( hr.IsMany ) {
			type = "IList<"+type+">";
		}
#>
		public virtual <#= type #> <#= hr.EdgePropName #> { get; private set; }
<#
	} //end edge loop
#>
		

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>Builder(TxBuilder pTx, <#= vertexType #> pVertex) : base(pTx, pVertex) {}
		
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>Builder(TxBuilder pTx) : base(pTx) {}

<#
	if ( !vertex.IsBaseClass ) {
		SchemaHelperProp pkProp = hn.GetPrimaryKeyProp();
		string pkName = pkProp.PropSchema.Name;
		string idType = pkProp.TypeName;
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>Builder(TxBuilder pTx, <#= idType #> p<#= pkName #>) : 
			base(pTx, new <#= vertex.Name #> { <#= pkName #> = p<#= pkName #> }) {}
		
<#
	} //end abstract condition

	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		string method = (hr.IsMany ? "AddTo" : "Set")+hr.EdgePropName;
		string t = hr.TargetVertexType;
		bool isRoot = (t == "Root");
		SchemaHelperProp targKeyProp = SchemaHelper.GetVertex(hr.TargetVertexType).GetPrimaryKeyProp();
		string targVertexIdType = (targKeyProp != null ? targKeyProp.TypeName : "XXX");
		string targPkName = targKeyProp.PropSchema.Name;
		
		if ( !isRoot ) {
#>		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public virtual void <#= method #>(IWeaverVarAlias<<#= t #>> pTargetVertexVar) {
<#
			if ( hr.IsOutgoing ) {
#>
			TxBuild.AddEdge<<#= hr.EdgeName #>>(VertexVar, pTargetVertexVar);
<#
			}
			else {
#>
			TxBuild.AddEdge<<#= hr.EdgeName #>>(pTargetVertexVar, VertexVar);
<#
			}
			
			if ( hr.IsMany ) {
#>
			<#= hr.EdgePropName #> = (<#= hr.EdgePropName #> ?? new List<IWeaverVarAlias<<#= t #>>>());
			<#= hr.EdgePropName #>.Add(pTargetVertexVar);
<#
			}
			else {
#>
			<#= hr.EdgePropName #> = pTargetVertexVar;
<#
			} //end is-many
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public virtual void <#= method #>(<#= t #> p<#= t #>, out IWeaverVarAlias<<#= t #>> pVertexVar) {
			TxBuild.GetVertex(p<#= t #>, out pVertexVar);
			<#= method #>(pVertexVar);
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public virtual void <#= method #>(<#= t #> p<#= t #>) {
			IWeaverVarAlias<<#= t #>> vertexVar;
			<#= method #>(p<#= t #>, out vertexVar);
		}
		
		/*--------------------------------------------------------------------------------------------*/
		//<#= targPkName #>
		public virtual void <#= method #>(<#= targVertexIdType #> p<#= targPkName #>, out IWeaverVarAlias<<#= t #>> pVertexVar) {
			<#= method #>(new <#= t #> { <#= targPkName #> = p<#= targPkName #> }, out pVertexVar);
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public virtual void <#= method #>(<#= targVertexIdType #> p<#= t #>Id) {
			IWeaverVarAlias<<#= t #>> vertexVar;
			<#= method #>(p<#= t #>Id, out vertexVar);
		}
		
<#
		} //end if/else
	} //end edge loop
#>

	}

<#
} //end vertex loop
#>
}
