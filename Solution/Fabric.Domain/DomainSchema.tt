<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Packages\Weaver\Weaver.dll" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Solution\Fabric.Domain.Schema\bin\Debug\Fabric.Domain.Schema.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Schema" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using Weaver.Items;
using Weaver.Interfaces;

//NEXT: support validation and restrictions

namespace Fabric.Domain {


	/* Relationship Types */


<#
var schema = new GraphSchema();
var relTypeMap = new Dictionary<string, bool>();

foreach ( WeaverRelSchema rel in schema.Rels ) {
	if ( relTypeMap.ContainsKey(rel.Name) ) { continue; }
	relTypeMap.Add(rel.Name, true);
#>
	/*================================================================================================*/
	public class <#= rel.Name #> : IWeaverRelType {

		public string Label { get { return "<#= rel.Name #>"; } }

	}

<#
}
#>

	/* Relationships */


<#
var relMap = new Dictionary<string, bool>();

foreach ( WeaverNodeSchema node in schema.Nodes ) {
	foreach ( WeaverRelSchema rel in schema.Rels ) {
		//var relOut = (rel.FromNode == node);
		//var relDir = (relOut ? "Out" : "In");
		//var relAmt = ((relOut && rel.Many) || (!relOut && rel.RevMany) ? "List" : "");
		var fromNode = rel.FromNode.Name;
		var toNode = rel.ToNode.Name;
		string relClass = fromNode+rel.Name+toNode;
		
		if ( relMap.ContainsKey(relClass) ) { continue; }
		relMap.Add(relClass, true);

		string interfaceTypes = "<IQuery"+rel.FromNode.Name+", IQuery"+rel.ToNode.Name+">";
		string classTypes = 
			"<"+
			"IQuery"+rel.FromNode.Name+", "+
			rel.FromNode.Name+", "+
			rel.Name+", "+
			"IQuery"+rel.ToNode.Name+", "+
			rel.ToNode.Name+
			">";
#>
	/*================================================================================================*/
	public interface I<#= GetRelClassName(node, rel) #> :
			IWeaverRel<#= interfaceTypes #>, IWeaverQueryRel {

		IQuery<#= rel.FromNode.Name #> From<#= rel.FromNode.Name #> { get; }
		IQuery<#= rel.ToNode.Name #> To<#= rel.ToNode.Name #> { get; }

	}

	/*================================================================================================*/
	public class <#= GetRelClassName(node, rel) #> :
			WeaverRel<#= classTypes #>,
			I<#= relClass #> {
			
		public virtual IQuery<#= rel.FromNode.Name #> From<#= rel.FromNode.Name #> { get { return FromNode; } }
		public virtual IQuery<#= rel.ToNode.Name #> To<#= rel.ToNode.Name #> { get { return ToNode; } }
		public override string Label { get { return "<#= rel.FromNode.Name+rel.Name+rel.ToNode.Name #>"; } }

	}

<#
	}
}
#>


	/* Query Nodes interfaces */


<#
foreach ( WeaverNodeSchema node in schema.Nodes ) {
#>
	/*================================================================================================*/
	public interface IQuery<#= node.Name #> : IWeaverQueryNode {

<#
	foreach ( WeaverRelSchema rel in schema.Rels ) {
		if ( rel.FromNode != node && rel.ToNode != node ) { continue; }
#>
		I<#= GetRelClassName(node, rel) #> <#= GetRelPropName(node, rel) #> { get; }
<#
	}
#>

	}

<#
}
#>

	/* Nodes */


<#
foreach ( WeaverNodeSchema node in schema.Nodes ) {
#>
	/*================================================================================================*/
	public class <#= node.Name #> : WeaverNode, IQuery<#= node.Name #> {

<#
	foreach ( WeaverPropSchema prop in node.Props ) { 
		string propType = prop.Type.Name;
		string propName = prop.Name;

		switch ( prop.Type.Name ) {
			case "Int64": propType = "long"; break;
			case "Byte": propType = "byte"; break;
			case "String": propType = "string"; break;
			case "Boolean": propType = "bool"; break;
			case "Single": propType = "float"; break;
			case "DateTime": propType = "long"; propName += "Timestamp"; break;
		}
#>
		public virtual <#= propType+" "+propName #> { get; set; }
<#
	}

	if ( node.IsRoot ) {
#>
		public override bool IsRoot { get { return true; } }
<#
	} //end if "isRoot"

	foreach ( WeaverRelSchema rel in schema.Rels ) {
		if ( rel.FromNode != node && rel.ToNode != node ) { continue; }
		string relClass = GetRelClassName(node, rel);
#>

		/*--------------------------------------------------------------------------------------------*/
		public virtual I<#= relClass #> <#= GetRelPropName(node, rel) #> {
			get { return NewRel<<#= relClass #>>(WeaverRelConn.<#= GetRelComm(node, rel) #>); }
		}
<#
	}
#>

	}

<#
}
#>

}
<#+
    public string GetRelClassName(WeaverNodeSchema pNode, WeaverRelSchema pRel) {
		return pRel.FromNode.Name + pRel.Name + pRel.ToNode.Name;
    }

	public string GetRelPropName(WeaverNodeSchema pNode, WeaverRelSchema pRel) {
		bool isOut = (pRel.FromNode == pNode);

		var fromNode = (isOut ? "" : (pRel.Many ? "Many" : "One")+pRel.FromNode.Name);
		var toNode = (!isOut ? "" : (pRel.RevMany ? "Many" : "One")+pRel.ToNode.Name);
		return (isOut ? "Out" : "In") + fromNode + pRel.Name + toNode;
    }

	public string GetRelComm(WeaverNodeSchema pNode, WeaverRelSchema pRel) {
		bool isOut = (pRel.FromNode == pNode);
		bool isMany = ((isOut && pRel.Many) || (!isOut && pRel.RevMany));
		return (isOut ? "OutTo" : "InFrom") + (isMany ? "Many" : "One") + "Node" + (isMany ? "s" : "");
    }
#>