<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.1.0.0\Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System;
using System.Linq.Expressions;
using Weaver.Items;
using Weaver.Interfaces;

namespace Fabric.Domain {


	/* Relationship Types */
	
	
<#
IList<string> relTypes = SchemaHelper.GetRelTypes();

foreach ( string name in relTypes ) {
#>
	/*================================================================================================*/
	public class <#= name #> : IWeaverRelType {
	
		public string Label { get { return "<#= name #>"; } }

	}

<#
} //end rel types loop
#>

	/* Relationships */


<#
IList<string> rels = SchemaHelper.GetRels();

foreach ( string name in rels ) {
	SchemaHelperRel rel = SchemaHelper.GetRel(name);
#>
	/*================================================================================================*/
	public class <#= rel.RelName #> : <#= rel.WeaverBaseClass #>, IItemWithId {
			
		public virtual <#= rel.FromNodeName #> From<#= rel.FromNodeName #> { get { return FromNode; } }
		public virtual <#= rel.ToNodeName #> To<#= rel.ToNodeName #> { get { return ToNode; } }
		public override string Label { get { return "<#= rel.RelName #>"; } }

	}

<#
} //end rel names loop
#>

	/* Nodes */


<#
IList<string> nodes = SchemaHelper.GetNodes();

foreach ( string name in nodes ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverNodeSchema node = hn.NodeSchema;
	bool isMainNode = (name == "Node");
	string baseNode = (isMainNode ? "" : " : "+(hn.HasParentClass ? node.BaseNode.Name : "Node"));
	string abs = (node.IsAbstract ? "abstract " : "");
#>
	/*================================================================================================*/
	public <#= abs #>partial class <#= node.Name #><#= baseNode #> {
	
<#
	IList<SchemaHelperProp> props = hn.GetProps(false);

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string attribs = "";
		string attEnd = "\r\n\t\t";

		if ( prop.Type.IsValueType && hp.IsSubProp() ) {
			propType += "?";
		}

		attribs += "[WeaverItemProperty]"+attEnd;

		if ( prop.IsCaseInsensitive != null ) {
			attribs += "//[PropIsCaseInsensitive("+prop.IsCaseInsensitive+")]"+attEnd;
		}

		if ( prop.IsNullable != null ) {
			attribs += "//[PropIsNullable("+prop.IsNullable+")]"+attEnd;
		}

		if ( prop.IsPrimaryKey != null ) {
			attribs += "//[PropIsPrimaryKey("+prop.IsPrimaryKey+")]"+attEnd;
		}

		if ( prop.IsTimestamp != null ) {
			attribs += "//[PropIsTimestamp("+prop.IsTimestamp+")]"+attEnd;
		}

		if ( prop.IsUnique != null ) {
			attribs += "//[PropIsUnique("+prop.IsUnique+")]"+attEnd;
		}

		if ( prop.IsInternal != null ) {
			attribs += "//[PropIsInternal("+prop.IsInternal+")]"+attEnd;
		}

		if ( prop.IsPassword != null ) {
			attribs += "//[PropIsPassword("+prop.IsPassword+")]"+attEnd;
		}

		if ( prop.Len != null ) {
			attribs += "//[PropLen("+prop.Len+")]"+attEnd;
		}

		if ( prop.LenMax != null ) {
			attribs += "//[PropLenMax("+prop.LenMax+")]"+attEnd;
		}

		if ( prop.LenMin != null ) {
			attribs += "//[PropLenMin("+prop.LenMin+")]"+attEnd;
		}

		if ( prop.ValidRegex != null ) {
			attribs += "//[PropValidRegex(@\""+prop.ValidRegex+"\")]"+attEnd;
		}

		if ( hp.IsSubProp() ) {
			attribs += "//[PropIsSubProp(\""+hp.SubPropName+"\")]"+attEnd;
		}
#>
		<#= attribs #>public virtual <#= propType+" "+propName #> { get; set; }

<#
	}

	if ( !node.IsAbstract ) {
		string fabType = (node.IsAbstract ? "Abstract" : (node.IsBaseClass ? "BaseClass" : node.Name));
		if ( fabType == "Root" ) { fabType = "Abstract"; }
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>() : base(NodeFabType.<#= fabType #>) {}

<#	
	} //end abstract condition

	if ( node.IsBaseClass && !isMainNode ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>(NodeFabType pFabType) : base(pFabType) {}

<#
	} //end base class condition

	if ( !node.IsAbstract ) {
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override long GetTypeId() { return <#= node.Name #>Id; }
		public override void SetTypeId(long pTypeId) { <#= node.Name #>Id = pTypeId; }
		
		/*--------------------------------------------------------------------------------------------*/
		public override Expression<Func<T, object>> GetTypeIdProp<T>() {
			return (x => (x as <#= node.Name #>).<#= node.Name #>Id);
		}

		
		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	} //end abstract condition

	IList<SchemaHelperNodeRel> nodeRels = hn.GetRels();

	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public virtual <#= hr.RelName #> <#= hr.RelPropName #> {
			get { return NewRel<<#= hr.RelName #>>(WeaverRelConn.<#= hr.Conn+"" #>); }
		}

<#
	}
#>
	}

<#
}
#>
}
