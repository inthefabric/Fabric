<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Elements" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using Fabric.Domain;
using Weaver.Core.Elements;

namespace Fabric.Domain {


	/* Edge Types */
	
	
<#
IList<string> edgeTypes = SchemaHelper.GetEdgeTypes();

foreach ( string name in edgeTypes ) {
#>
	/*================================================================================================*/
	public class <#= name #> : IWeaverEdgeType {
	
		public string Label { get { return "<#= name #>"; } }

	}

<#
} //end edge types loop
#>

	/* Edges */


<#
IList<string> edges = SchemaHelper.GetEdges();

foreach ( string name in edges ) {
	SchemaHelperRel edge = SchemaHelper.GetEdge(name);
#>
	/*================================================================================================*/
	public class <#= edge.EdgeName #> : Rel<<#= edge.OutVertexName #>, <#=edge.EdgeTypeName #>, <#= edge.InVertexName #>>, IItemWithId {
			
		public virtual <#= edge.OutVertexName #> From<#= edge.OutVertexName #> { get { return OutVertex; } }
		public virtual <#= edge.InVertexName #> To<#= edge.InVertexName #> { get { return InVertex; } }
		public override string Label { get { return "<#= edge.EdgeName #>"; } }

<#
		WeaverVertexSchema hnOut = SchemaHelper.GetNode(edge.OutVertexName).NodeSchema;
		WeaverVertexSchema hnIn = SchemaHelper.GetNode(edge.InVertexName).NodeSchema;
		
		if ( hnOut.IsBaseClass && !hnOut.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------* /
		public override bool IsValidOutVertexType(Type pType) {
			return typeof(Artifact<>).IsAssignableFrom(pType);
		}*/

<#
		} //end Out condition

		if ( hnIn.IsBaseClass && !hnIn.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------* /
		public override bool IsValidInVertexType(Type pType) {
			if ( pType.IsGenericType && pType.GetGenericTypeDefinition() == typeof(Artifact<>) ) {
				return true;
			}

			return (pType.BaseType != null && pType.BaseType.IsGenericType &&
				pType.BaseType.GetGenericTypeDefinition() == typeof(Artifact<>));
		}*/

<#
		} //end In condition
#>
	}
	
<#
} //end edge names loop
#>


	/* Vertices */


<#
IList<string> nodes = SchemaHelper.GetVertices();

foreach ( string name in nodes ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverVertexSchema node = hn.NodeSchema;
	bool isMainNode = (name == "Node");
	string baseNode = (isMainNode ? "" : " : "+(hn.HasParentClass ? node.BaseVertex.Name : "Node"));
	string abs = (node.IsAbstract ? "abstract " : "");
	bool isArtifactSubclass = (node.BaseVertex != null && node.BaseVertex.Name == "Artifact");

	if ( node.IsBaseClass ) {
#>
	/*================================================================================================*/
	public <#= abs #>partial class <#= node.Name #><#= baseNode #> {
	
<#
	}
	else {
#>
	/*================================================================================================*/
	public <#= abs #>partial class <#= node.Name #><#= baseNode #> {
	
<#
	}

	IList<SchemaHelperProp> props = hn.GetProps(false);

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;

		if ( prop.Type.IsValueType && hp.IsSubProp() ) {
			propType += "?";
		}
#>
		[WeaverItemProperty]
		public virtual <#= propType+" "+propName #> { get; set; }

<#
	}

	if ( !node.IsAbstract ) {
		string fabType = (node.IsAbstract ? "Abstract" : (node.IsBaseClass ? "BaseClass" : node.Name));
		if ( fabType == "Root" ) { fabType = "Abstract"; }
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>() : base(NodeFabType.<#= fabType #>) {}

<#	
	} //end abstract condition

	if ( node.IsBaseClass && !isMainNode ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>(NodeFabType pFabType) : base(pFabType) {}

<#
	} //end base class condition

	if ( !node.IsAbstract && !isArtifactSubclass ) {
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override long GetTypeId() { return <#= node.Name #>Id; }
		public override void SetTypeId(long pTypeId) { <#= node.Name #>Id = pTypeId; }
		
		/*--------------------------------------------------------------------------------------------*/
		public override Expression<Func<T, object>> GetTypeIdProp<T>() {
			return (x => (x as <#= node.Name #>).<#= node.Name #>Id);
		}

<#
	} //end abstract condition

	string fillOver = (isMainNode ? "virtual" : "override");
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= fillOver #> void FillWithData(IDictionary<string,string> pData) {
			if ( pData == null ) {
				return;
			}
<#
		if ( node.BaseVertex != null ) {
#>
			
			base.FillWithData(pData);
<#
		} //end BaseVertex condition

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName.Replace("?", "");;
#>
			
			if ( pData.ContainsKey("<#= prop.DbName #>") ) {
<#
			if ( prop.Type.IsValueType ) {
#>
				<#= prop.Name #> = <#= propType #>.Parse(pData["<#= prop.DbName #>"]);
<#
			}
			else {
#>
				<#= prop.Name #> = pData["<#= prop.DbName #>"];
<#
			} //end value type condition
#>
			}
<#
	} //end prop loop
#>

		}

<#
	IList<SchemaHelperNodeRel> nodeRels = hn.GetEdges();

	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public virtual <#= hr.EdgeName #> <#= hr.RelPropName #> {
			get { return NewEdge<<#= hr.EdgeName #>>(WeaverEdgeConn.<#= hr.Conn+"" #>); }
		}

<#
	}
#>
	}

<#
}
#>
}
