<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.4.0\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.Titan.0.4.0\lib\Weaver.Titan.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Elements" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using Weaver.Core.Elements;
using Weaver.Titan.Elements;

namespace Fabric.Domain {


	/* Edge Types */
	
	
<#
IList<string> edgeTypes = SchemaHelper.GetEdgeTypes();

foreach ( string name in edgeTypes ) {
#>
	/*================================================================================================*/
	public class <#= name #> : IWeaverEdgeType {
	
		public string Label { get { return "<#= name #>"; } }

	}

<#
} //end edge types loop
#>

	/* Edges */


<#
IList<string> edges = SchemaHelper.GetEdges();

foreach ( string name in edges ) {
	SchemaHelperEdge he = SchemaHelper.GetEdge(name);
	WeaverEdgeSchema edge = he.EdgeSchema;
#>
	/*================================================================================================*/
	[WeaverTitanEdge("<#= edge.DbName #>", WeaverEdgeConn.<#= edge.OutVertexConn #>, typeof(<#= he.OutVertexName #>),
		WeaverEdgeConn.<#= edge.InVertexConn #>, typeof(<#= he.InVertexName #>))]
	public class <#= he.EdgeName #> : Edge<<#= he.OutVertexName #>, <#=he.EdgeTypeName #>, <#= he.InVertexName #>>, IItemWithId {
			
		public virtual <#= he.OutVertexName #> From<#= he.OutVertexName #> { get { return OutVertex; } }
		public virtual <#= he.InVertexName #> To<#= he.InVertexName #> { get { return InVertex; } }

	}
	
<#
} //end edge names loop
#>


	/* Vertices */


<#
IList<string> verts = SchemaHelper.GetVertices();

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	bool isMainVertex = (name == "Vertex");
	string baseVertex = (isMainVertex ? "" : " : "+(hn.HasParentClass ? vertex.BaseVertex.Name : "Vertex"));
	string abs = (vertex.IsAbstract ? "abstract " : "");
	bool isArtifactSubclass = (vertex.BaseVertex != null && vertex.BaseVertex.Name == "Artifact");

	if ( vertex.IsBaseClass ) {
#>
	/*================================================================================================*/
	[WeaverTitanVertex] //allows this class to be included in SetupIndexes
	public <#= abs #>partial class <#= vertex.Name #><#= baseVertex #> {
	
<#
	}
	else {
#>
	/*================================================================================================*/
	[WeaverTitanVertex]
	public <#= abs #>partial class <#= vertex.Name #><#= baseVertex #> {
	
<#
	}

	IList<SchemaHelperProp> props = hn.GetProps(false);

	foreach ( SchemaHelperProp hp in props ) { 
		FabricPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;

		if ( prop.Type.IsValueType && hp.IsSubProp() ) {
			propType += "?";
		}

		string index = (prop.TitanIndex == true ? "true" : "false");
		string elast = (prop.TitanElasticIndex == true ? "true" : "false");
#>
		[WeaverTitanProperty("<#= prop.DbName #>", TitanIndex=<#= index #>, TitanElasticIndex=<#= elast #>)]
		public virtual <#= propType+" "+propName #> { get; set; }

<#
	}

	if ( !vertex.IsAbstract ) {
		string fabType = (vertex.IsAbstract ? "Abstract" : (vertex.IsBaseClass ? "BaseClass" : vertex.Name));
		if ( fabType == "Root" ) { fabType = "Abstract"; }
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>() : base(VertexFabType.<#= fabType #>) {}

<#	
	} //end abstract condition

	if ( vertex.IsBaseClass && !isMainVertex ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>(VertexFabType pFabType) : base(pFabType) {}

<#
	} //end base class condition

	if ( !vertex.IsAbstract && !isArtifactSubclass ) {
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override long GetTypeId() { return <#= vertex.Name #>Id; }
		public override void SetTypeId(long pTypeId) { <#= vertex.Name #>Id = pTypeId; }
		
		/*--------------------------------------------------------------------------------------------*/
		public override Expression<Func<T, object>> GetTypeIdProp<T>() {
			return (x => (x as <#= vertex.Name #>).<#= vertex.Name #>Id);
		}

<#
	} //end abstract condition

	string fillOver = (isMainVertex ? "virtual" : "override");
#>

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= fillOver #> void FillWithData(IDictionary<string,string> pData) {
			if ( pData == null ) {
				return;
			}
<#
		if ( vertex.BaseVertex != null ) {
#>
			
			base.FillWithData(pData);
<#
		} //end BaseVertex condition

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName.Replace("?", "");;
#>
			
			if ( pData.ContainsKey("<#= prop.DbName #>") ) {
<#
			if ( prop.Type.IsValueType ) {
#>
				<#= prop.Name #> = <#= propType #>.Parse(pData["<#= prop.DbName #>"]);
<#
			}
			else {
#>
				<#= prop.Name #> = pData["<#= prop.DbName #>"];
<#
			} //end value type condition
#>
			}
<#
	} //end prop loop
#>

		}

<#
	IList<SchemaHelperVertexEdge> vertexEdges = hn.GetEdges();

	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public virtual <#= hr.EdgeName #> <#= hr.EdgePropName #> {
			get { return NewEdge<<#= hr.EdgeName #>>(WeaverEdgeConn.<#= hr.Conn+"" #>); }
		}

<#
	}
#>
	}

<#
}
#>
}
