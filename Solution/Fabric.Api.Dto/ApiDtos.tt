<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver\Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Schema\bin\Debug\Fabric.Domain.Schema.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Infrastructure\bin\Debug\Fabric.Infrastructure.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Schema" #>
<#@ import namespace="Fabric.Infrastructure" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;

namespace Fabric.Api.Dto {
	
<#
var schema = new GraphSchema();

foreach ( WeaverNodeSchema node in schema.Nodes ) {
	string baseNode = "Fab"+(node.BaseNode == null ? "Node" : node.BaseNode.Name);
	var propNameMap = new Dictionary<string,string>();
	var propTypeMap = new Dictionary<string,string>();
	bool hasTypeId = false;
#>
	/*================================================================================================*/
	public <#= (node.IsAbstract ? "abstract " : "") #>class Fab<#= node.Name #> : <#= baseNode #> {
	
<#
	foreach ( WeaverPropSchema prop in node.Props ) { 
		string propType = prop.Type.Name;
		string propName = prop.Name;
		string attribs = "";
		string attEnd = "\r\n\t\t";

		if ( propName == node.Name+"Id" ) {
			hasTypeId = true;
		}
		
		propType = FabricUtil.GetTypeDisplayName(prop.Type);
		
		switch ( prop.Type.Name ) {
			case "DateTime": propName += "Timestamp"; break;
		}

		if ( prop.IsCaseInsensitive != null ) {
			attribs += "//[PropIsCaseInsensitive("+prop.IsCaseInsensitive+")]"+attEnd;
		}

		if ( prop.IsNullable != null ) {
			attribs += "//[PropIsNullable("+prop.IsNullable+")]"+attEnd;
		}

		if ( prop.IsPrimaryKey != null ) {
			attribs += "//[PropIsPrimaryKey("+prop.IsPrimaryKey+")]"+attEnd;
		}

		if ( prop.IsTimestamp != null ) {
			attribs += "//[PropIsTimestamp("+prop.IsTimestamp+")]"+attEnd;
		}
		
		if ( prop.IsUnique != null ) {
			attribs += "//[PropIsUnique("+prop.IsUnique+")]"+attEnd;
		}

		if ( prop.Len != null ) {
			attribs += "//[PropLen("+prop.Len+")]"+attEnd;
		}

		if ( prop.LenMax != null ) {
			attribs += "//[PropLenMax("+prop.LenMax+")]"+attEnd;
		}

		if ( prop.LenMin != null ) {
			attribs += "//[PropLenMin("+prop.LenMin+")]"+attEnd;
		}

		if ( prop.ValidRegex != null ) {
			attribs += "//[PropValidRegex(@\""+prop.ValidRegex+"\")]"+attEnd;
		}
		
		propNameMap.Add(prop.Name, propName);
		propTypeMap.Add(prop.Name, propType);

#>
		<#= attribs #>public <#= propType+" "+propName #> { get; set; }

<#
	} //end prop loop

	if ( !node.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override long TypeId { get { return <#= (hasTypeId ? node.Name+"Id" : "0") #>; } }

<#
	} //end non-abstract
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void FillResultData(Dictionary<string,string> pData) {
<#
	if ( baseNode != "FabNode" ) {
#>
			base.FillResultData(pData);

<#
	} //end non-FabNode baseNode

	bool showFound = false;
	bool showVal = (node.Props.Count > 0);

	foreach ( WeaverPropSchema prop in node.Props ) { 
		if ( prop.IsNullable == true || propTypeMap[prop.Name] == "string" ) {
			showFound = true;
		}
	}

	if ( showVal ) { 
#>
			string val;
<#
	} //end showVal
	
	if ( showFound ) { 
#>
			bool found;
<#
	} //end showFound

	foreach ( WeaverPropSchema prop in node.Props ) { 
		string propName = propNameMap[prop.Name];
		string propType = propTypeMap[prop.Name];
		string parseType = propType.Replace("?", "");
		//if ( < #= parseType # >.TryParse(val, out typedVal) ) { < #= propName # > = typedVal; }
#>

<#
		if ( prop.IsNullable == true || propType == "string" ) {
#>
			found = pData.TryGetValue("<#= propName #>", out val);
<#
		}
		else { //not string nor nullable
#>
			val = pData["<#= propName #>"];
<#
		}

		if ( propType == "string" ) {
#>
			if ( found ) { <#= propName #> = val; }
<#
		}
		else if ( prop.IsNullable != null ) {
#>
			if ( found ) { <#= propName #> = <#= parseType #>.Parse(val); }
<#
		}
		else { //not string nor nullable
#>
			<#= propName #> = <#= parseType #>.Parse(val);
<#
		}

	} //end prop loop
#>
		}

	}

<#
} // end Node loop
#>
}