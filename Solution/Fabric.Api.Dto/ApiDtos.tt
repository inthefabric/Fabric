<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Packages\Weaver\Weaver.dll" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Solution\Fabric.Domain.Schema\bin\Debug\Fabric.Domain.Schema.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Schema" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using Fabric.Infrastructure;

namespace Fabric.Api.Dto {
	
<#
var schema = new GraphSchema();

foreach ( WeaverNodeSchema node in schema.Nodes ) {
	string baseNode = "Fab"+(node.BaseNode == null ? "Node" : node.BaseNode.Name);
	var propNameMap = new Dictionary<string,string>();
	var propTypeMap = new Dictionary<string,string>();
#>
	/*================================================================================================*/
	public <#= (node.IsAbstract ? "abstract " : "") #>class Fab<#= node.Name #> : <#= baseNode #> {
	
<#
	foreach ( WeaverPropSchema prop in node.Props ) { 
		string propType = prop.Type.Name;
		string propName = prop.Name;
		string attribs = "";
		string attEnd = "\r\n\t\t";
		
		switch ( prop.Type.Name ) {
			case "Int32": propType = "int"; break;
			case "Int64": propType = "long"; break;
			case "Byte": propType = "byte"; break;
			case "String": propType = "string"; break;
			case "Boolean": propType = "bool"; break;
			case "Single": propType = "float"; break;
			case "Double": propType = "double"; break;
			case "DateTime": propType = "long"; propName += "Timestamp"; break;
		}

		if ( prop.IsCaseInsensitive != null ) {
			attribs += "//[PropIsCaseInsensitive("+prop.IsCaseInsensitive+")]"+attEnd;
		}

		if ( prop.IsNullable != null ) {
			attribs += "//[PropIsNullable("+prop.IsNullable+")]"+attEnd;
		}

		if ( prop.IsPrimaryKey != null ) {
			attribs += "//[PropIsPrimaryKey("+prop.IsPrimaryKey+")]"+attEnd;
		}

		if ( prop.IsTimestamp != null ) {
			attribs += "//[PropIsTimestamp("+prop.IsTimestamp+")]"+attEnd;
		}
		
		if ( prop.IsUnique != null ) {
			attribs += "//[PropIsUnique("+prop.IsUnique+")]"+attEnd;
		}

		if ( prop.Len != null ) {
			attribs += "//[PropLen("+prop.Len+")]"+attEnd;
		}

		if ( prop.LenMax != null ) {
			attribs += "//[PropLenMax("+prop.LenMax+")]"+attEnd;
		}

		if ( prop.LenMin != null ) {
			attribs += "//[PropLenMin("+prop.LenMin+")]"+attEnd;
		}

		if ( prop.ValidRegex != null ) {
			attribs += "//[PropValidRegex(@\""+prop.ValidRegex+"\")]"+attEnd;
		}
		
		propNameMap.Add(prop.Name, propName);
		propTypeMap.Add(prop.Name, propType);

#>
		<#= attribs #>public <#= propType+" "+propName #> { get; set; }

<#
	} //end prop loop

#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void FillResultData(Dictionary<string,string> pData) {
			string val;
			bool found;
<#
	foreach ( WeaverPropSchema prop in node.Props ) { 
		string propName = propNameMap[prop.Name];
		string propType = propTypeMap[prop.Name];
		string parseType = propType.Replace("?", "");
		//if ( < #= parseType # >.TryParse(val, out typedVal) ) { < #= propName # > = typedVal; }
#>

<#
		if ( prop.IsNullable == true || propType == "string" ) {
#>
			found = pData.TryGetValue("<#= propName #>", out val);
<#
		}
		else { //not string nor nullable
#>
			val = pData["<#= propName #>"];
<#
		}

		if ( propType == "string" ) {
#>
			if ( found ) { <#= propName #> = val; }
<#
		}
		else if ( prop.IsNullable != null ) {
#>
			if ( found ) { <#= propName #> = <#= parseType #>.Parse(val); }
<#
		}
		else { //not string nor nullable
#>
			<#= propName #> = <#= parseType #>.Parse(val);
<#
		}

	} //end prop loop
#>
		}

	}

<#
} // end Node loop
#>
}