<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.4.2\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.Titan.0.4.2\lib\Weaver.Titan.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Packages/Weaver/Weaver.Core.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Domain/bin/Debug/Fabric.Domain.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System;
using System.Collections.Generic;
using System.Linq;
using Fabric.Domain;
using Fabric.Infrastructure.Db;

namespace Fabric.Api.Dto.Traversal {
	
<#
IList<string> verts = SchemaHelper.GetVertices();

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsInternal ) { continue; }

	string baseVertex = (hn.HasParentClass ? vertex.BaseVertex.Name : "Vertex");
	string abs = (vertex.IsAbstract ? "abstract " : "");
	bool hasTypeId = false;
#>
	/*================================================================================================*/
	public <#= abs #>class Fab<#= vertex.Name #> : Fab<#= baseVertex #> {
<#
	IList<SchemaHelperProp> props = hn.GetProps(true, true);
	string propList = "";

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string isOpt = (prop.IsNullable == true ? "true" : "false");

		if ( propName == vertex.Name+"Id" ) {
			hasTypeId = true;
		}

		propList += (propList == "" ? "" : ", ")+"\""+propName+"\"";
#>
		
		[DtoProp(IsOptional=<#= isOpt #>)]
		public <#= propType+" "+propName #> { get; set; }
<#
	} //end prop loop

	IList<string> subNames = hn.GetSubNames();

	foreach ( string subName in subNames ) { 
		IList<SchemaHelperProp> subProps = hn.GetSubProps(subName);
		string subOpt = hn.GetSubPropIsOptional(subName).ToString().ToLower();

		foreach ( SchemaHelperProp hp in subProps ) {
			propList += (propList == "" ? "" : ", ")+"\""+subName+"."+hp.SubPropName+"\"";
		}
#>
		
		[DtoProp(IsOptional=<#= subOpt #>)]
		public Fab<#= subName+" "+subName #> { get; set; }
<#
	} //end prop loop
#>
		
		private static readonly List<string> AvailVertexProps = new List<string> {
			<#= propList #>
		};


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= vertex.Name #>() {}
		
<#
	if ( !vertex.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= vertex.Name #>(<#= vertex.Name #> pVertex) : this() {
			FillWithVertex(pVertex);
		}
		
<#
		if ( hasTypeId ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override long TypeId { get { return <#= vertex.Name+"Id" #>; } }
		
<#
		} //end typeId condition
	} //end non-abstract
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void FillResultData(IDictionary<string,string> pData) {
<#
	if ( baseVertex != "Vertex" ) {
#>
			base.FillResultData(pData);

<#
	} //end non-FabVertex baseVertex
	
	bool showFound = false;
	bool showVal = (vertex.Props.Count > 0);
	
	foreach ( SchemaHelperProp hp in props ) { 
		if ( hp.PropSchema.IsNullable == true || hp.TypeName == "string" ) {
			showFound = true;
		}
	}

	if ( showVal ) { 
#>
			string val;
<#
	} //end showVal
	
	if ( showFound ) { 
#>
			bool found;
<#
	} //end showFound

	props = hn.GetProps(true, false);
	
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string propDbName = hp.PropSchema.DbName;
		string dotPropName = hp.PropSchema.Name.Replace('_', '.');
		string parseType = propType.Replace("?", "");
#>

<#
		if ( hp.PropSchema.IsNullable == true || propType == "string" || hp.IsSubProp() ) {
#>
			found = pData.TryGetValue("<#= propDbName #>", out val);
<#
		}
		else { //not string nor nullable
#>
			val = pData["<#= propDbName #>"];
<#
		}

		if ( propType == "string" ) {
#>
			if ( found ) { <#= dotPropName #> = val; }
<#
		}
		else if ( hp.IsSubProp() ) {
			string subName = propName.Substring(0, propName.IndexOf('_'));
#>
			if ( found ) {
				if ( <#= subName #> == null ) { <#= subName #> = new Fab<#= subName #>(); }
				<#= dotPropName #> = <#= parseType #>.Parse(val);
			}
<#
		}
		else if ( hp.PropSchema.IsNullable == true ) {
#>
			if ( found ) { <#= dotPropName #> = <#= parseType #>.Parse(val); }
<#
		}
		else { //not string nor nullable
#>
			<#= dotPropName #> = <#= parseType #>.Parse(val);
<#
		}

	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
<#
	if ( vertex.IsAbstract ) {
#>
		public void FillWithVertex<T>(T pVertex) where T : <#= vertex.Name #> {
<#
	}
	else {
#>
		public void FillWithVertex(<#= vertex.Name #> pVertex) {
<#
	} //end IsAbstract condition
#>
			base.FillWithVertex(pVertex);
<#
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string dotPropName = hp.PropSchema.Name.Replace('_', '.');
		string parseType = propType.Replace("?", "");

		if ( hp.IsSubProp() ) {
			string subName = propName.Substring(0, propName.IndexOf('_'));
#>

			if ( pVertex.<#= propName #> != null ) {
				if ( <#= subName #> == null ) { <#= subName #> = new Fab<#= subName #>(); }
				<#= dotPropName #> = (<#= propType #>)pVertex.<#= propName #>;
			}
<#		}
		else {
#>
			<#= dotPropName #> = pVertex.<#= propName #>;
<#
		}//end subprop condition

	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override List<string> AvailableProps {
			get { return base.AvailableProps.Concat(AvailVertexProps).ToList(); }
		}

	}
<#
	if ( subNames.Count > 0 ) {
		foreach ( string subName in subNames ) {
#>


	/*================================================================================================*/
	public class Fab<#= subName #> : FabObject {
	
<#
			IList<SchemaHelperProp> subProps = hn.GetSubProps(subName);

			foreach ( SchemaHelperProp hp in subProps ) {
#>
		public <#= hp.TypeName #> <#= hp.SubPropName #> { get; set; }
<#
			} //end subProp loop
#>


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override void Fill(IDbDto pDbDto) {
			throw new NotImplementedException();
		}

	}
<#
		} //end subname loop
	} //end subName count condition
} // end Vertex loop
#>
}