<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Packages/Weaver.1.0.0/Weaver.dll" #>
<#@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Domain/bin/Debug/Fabric.Domain.dll" #>
<#@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Infrastructure/bin/Debug/Fabric.Infrastructure.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Infrastructure.Domain" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using System.Linq;
using Fabric.Domain;

namespace Fabric.Api.Dto.Traversal {
	
<#
IList<string> nodes = SchemaHelper.GetNodes();

foreach ( string name in nodes ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverNodeSchema node = hn.NodeSchema;
	if ( node.IsInternal ) { continue; }

	string baseNode = (hn.HasParentClass ? node.BaseNode.Name : "Node");
	string abs = (node.IsAbstract ? "abstract " : "");
	bool hasTypeId = false;
#>
	/*================================================================================================*/
	public <#= abs #>class Fab<#= node.Name #> : Fab<#= baseNode #> {
<#
	IList<SchemaHelperProp> props = hn.GetProps(true);
	string propList = "";

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string isOpt = (prop.IsNullable == true ? "true" : "false");

		if ( propName == node.Name+"Id" ) {
			hasTypeId = true;
		}

		propList += (propList == "" ? "" : ", ")+"\""+propName+"\"";
#>
		
		[DtoProp(IsOptional=<#= isOpt #>)]
		public <#= propType+" "+propName #> { get; set; }
<#
	} //end prop loop
#>
		
		private static readonly List<string> AvailNodeProps = new List<string> {
			<#= propList #>
		};


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= node.Name #>() {}
		
<#
	if ( !node.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= node.Name #>(<#= node.Name #> pNode) : this() {
			FillWithNode(pNode);
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override long TypeId { get { return <#= (hasTypeId ? node.Name+"Id" : "0") #>; } }

<#
	} //end non-abstract
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void FillResultData(IDictionary<string,string> pData) {
<#
	if ( baseNode != "Node" ) {
#>
			base.FillResultData(pData);

<#
	} //end non-FabNode baseNode

	bool showFound = false;
	bool showVal = (node.Props.Count > 0);
	
	foreach ( SchemaHelperProp hp in props ) { 
		if ( hp.PropSchema.IsNullable == true || hp.TypeName == "string" ) {
			showFound = true;
		}
	}

	if ( showVal ) { 
#>
			string val;
<#
	} //end showVal
	
	if ( showFound ) { 
#>
			bool found;
<#
	} //end showFound
	
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string parseType = propType.Replace("?", "");
#>

<#
		if ( hp.PropSchema.IsNullable == true || propType == "string" ) {
#>
			found = pData.TryGetValue("<#= propName #>", out val);
<#
		}
		else { //not string nor nullable
#>
			val = pData["<#= propName #>"];
<#
		}

		if ( propType == "string" ) {
#>
			if ( found ) { <#= propName #> = val; }
<#
		}
		else if ( hp.PropSchema.IsNullable != null ) {
#>
			if ( found ) { <#= propName #> = <#= parseType #>.Parse(val); }
<#
		}
		else { //not string nor nullable
#>
			<#= propName #> = <#= parseType #>.Parse(val);
<#
		}

	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public void FillWithNode(<#= node.Name #> pNode) {
			base.FillWithNode(pNode);
<#
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string parseType = propType.Replace("?", "");
#>
			<#= propName #> = pNode.<#= propName #>;
<#
	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override List<string> AvailableProps {
			get { return base.AvailableProps.Concat(AvailNodeProps).ToList(); }
		}

	}

<#
} // end Node loop
#>
}