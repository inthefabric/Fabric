<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.1.0.0\Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Packages/Weaver.1.0.0/Weaver.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Domain/bin/Debug/Fabric.Domain.dll" #>
<# //@ assembly name="/Users/zachkinstner/Documents/FabricProject/Fabric2/Solution/Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System;
using System.Collections.Generic;
using System.Linq;
using Fabric.Domain;
using Fabric.Infrastructure.Db;

namespace Fabric.Api.Dto.Traversal {
	
<#
IList<string> nodes = SchemaHelper.GetNodes();

foreach ( string name in nodes ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverNodeSchema node = hn.NodeSchema;
	if ( node.IsInternal ) { continue; }

	string baseNode = (hn.HasParentClass ? node.BaseNode.Name : "Node");
	string abs = (node.IsAbstract ? "abstract " : "");
	bool hasTypeId = false;
#>
	/*================================================================================================*/
	public <#= abs #>class Fab<#= node.Name #> : Fab<#= baseNode #> {
<#
	IList<SchemaHelperProp> props = hn.GetProps(true, true);
	string propList = "";

	foreach ( SchemaHelperProp hp in props ) { 
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string isOpt = (prop.IsNullable == true ? "true" : "false");

		if ( propName == node.Name+"Id" ) {
			hasTypeId = true;
		}

		propList += (propList == "" ? "" : ", ")+"\""+propName+"\"";
#>
		
		[DtoProp(IsOptional=<#= isOpt #>)]
		public <#= propType+" "+propName #> { get; set; }
<#
	} //end prop loop

	IList<string> subNames = hn.GetSubNames();

	foreach ( string subName in subNames ) { 
		IList<SchemaHelperProp> subProps = hn.GetSubProps(subName);

		foreach ( SchemaHelperProp hp in subProps ) {
			propList += (propList == "" ? "" : ", ")+"\""+subName+"."+hp.SubPropName+"\"";
		}
#>
		
		[DtoProp(IsOptional=true)]
		public Fab<#= subName+" "+subName #> { get; set; }
<#
	} //end prop loop
#>
		
		private static readonly List<string> AvailNodeProps = new List<string> {
			<#= propList #>
		};


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= node.Name #>() {}
		
<#
	if ( !node.IsAbstract ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		public Fab<#= node.Name #>(<#= node.Name #> pNode) : this() {
			FillWithNode(pNode);
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override long TypeId { get { return <#= (hasTypeId ? node.Name+"Id" : "0") #>; } }
		
<#
	} //end non-abstract
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void FillResultData(IDictionary<string,string> pData) {
<#
	if ( baseNode != "Node" ) {
#>
			base.FillResultData(pData);

<#
	} //end non-FabNode baseNode
	
	bool showFound = false;
	bool showVal = (node.Props.Count > 0);
	
	foreach ( SchemaHelperProp hp in props ) { 
		if ( hp.PropSchema.IsNullable == true || hp.TypeName == "string" ) {
			showFound = true;
		}
	}

	if ( showVal ) { 
#>
			string val;
<#
	} //end showVal
	
	if ( showFound ) { 
#>
			bool found;
<#
	} //end showFound

	props = hn.GetProps(true, false);
	
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string propDbName = hp.PropSchema.DbName;
		string dotPropName = hp.PropSchema.Name.Replace('_', '.');
		string parseType = propType.Replace("?", "");
#>

<#
		if ( hp.PropSchema.IsNullable == true || propType == "string" || hp.IsSubProp() ) {
#>
			found = pData.TryGetValue("<#= propDbName #>", out val);
<#
		}
		else { //not string nor nullable
#>
			val = pData["<#= propDbName #>"];
<#
		}

		if ( propType == "string" ) {
#>
			if ( found ) { <#= dotPropName #> = val; }
<#
		}
		else if ( hp.IsSubProp() ) {
			string subName = propName.Substring(0, propName.IndexOf('_'));
#>
			if ( found ) {
				if ( <#= subName #> == null ) { <#= subName #> = new Fab<#= subName #>(); }
				<#= dotPropName #> = <#= parseType #>.Parse(val);
			}
<#
		}
		else if ( hp.PropSchema.IsNullable == true ) {
#>
			if ( found ) { <#= dotPropName #> = <#= parseType #>.Parse(val); }
<#
		}
		else { //not string nor nullable
#>
			<#= dotPropName #> = <#= parseType #>.Parse(val);
<#
		}

	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public void FillWithNode(<#= node.Name #> pNode) {
			base.FillWithNode(pNode);
<#
	foreach ( SchemaHelperProp hp in props ) { 
		string propType = hp.TypeName;
		string propName = hp.PropSchema.Name;
		string dotPropName = hp.PropSchema.Name.Replace('_', '.');
		string parseType = propType.Replace("?", "");

		if ( hp.IsSubProp() ) {
			string subName = propName.Substring(0, propName.IndexOf('_'));
#>

			if ( pNode.<#= propName #> != null ) {
				if ( <#= subName #> == null ) { <#= subName #> = new Fab<#= subName #>(); }
				<#= dotPropName #> = (<#= propType #>)pNode.<#= propName #>;
			}
<#		}
		else {
#>
			<#= dotPropName #> = pNode.<#= propName #>;
<#
		}//end subprop condition

	} //end prop loop
#>
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override List<string> AvailableProps {
			get { return base.AvailableProps.Concat(AvailNodeProps).ToList(); }
		}

	}
<#
	if ( subNames.Count > 0 ) {
		foreach ( string subName in subNames ) {
#>


	/*================================================================================================*/
	public class Fab<#= subName #> : FabObject {
	
<#
			IList<SchemaHelperProp> subProps = hn.GetSubProps(subName);

			foreach ( SchemaHelperProp hp in subProps ) {
#>
		public <#= hp.TypeName #> <#= hp.SubPropName #> { get; set; }
<#
			} //end subProp loop
#>


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override void Fill(IDbDto pDbDto) {
			throw new NotImplementedException();
		}

	}
<#
		} //end subname loop
	} //end subName count condition
} // end Node loop
#>
}