<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Fabric.New.Domain.Schemas\bin\Debug\Fabric.New.Domain.Schemas.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Edges" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Utils" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Vertices" #>
<#@ output extension=".cs" #>

// GENERATED CODE
// Changes made to this source file will be overwritten

using Fabric.New.Api.Objects.Conversions;
using Fabric.New.Domain;
using Fabric.New.Domain.Enums;

namespace Fabric.New.Api.Objects {
<#
IList<IVertexSchema> verts = SchemaUtil.GetVertexSchemas();

foreach ( IVertexSchema v in verts ) { 
	OutputVertex(v, false);
}

foreach ( IVertexSchema v in verts ) { 
	OutputVertex(v, true);
}
#>

}
<#+
public void OutputVertex(IVertexSchema pVertex, bool pCreateMode) {
	IVertexSchema v = pVertex;
	IVertexSchema vp = SchemaUtil.GetVertexParent(v);

	string apiNamePrefix = (pCreateMode ? "Create" : "");
	string apiName = apiNamePrefix+v.Names.Api;
	string objectName = apiNamePrefix+"FabElement";
	string baseName = (vp == null ? objectName : apiNamePrefix+vp.Names.Api);
	string subBaseName = apiNamePrefix+"FabObject";

	IList<ApiProperty> props = SchemaUtil.GetVertexApiProperties(v, true, pCreateMode);
	IList<IEdgeSchema> edges = SchemaUtil.GetEdgeSchemasForVertex(v, true);
	var keepEdges = new List<IEdgeSchema>();
	IDictionary<string, IList<ApiProperty>> subMap = SchemaUtil.GetVertexApiPropertySubMap(v);
	var subPropMap = new Dictionary<string, IList<IEdgeSchema>>();

	foreach ( string key in subMap.Keys ) {
		subPropMap.Add(key, new List<IEdgeSchema>());
	}
#>		

	/*================================================================================================*/
	public class <#= apiName #> : <#= baseName #> {

<#+
	foreach ( ApiProperty ap in props ) {
		OutputVertexProp(ap, pCreateMode);
	}

	foreach ( IEdgeSchema es in edges ) {
		if ( !pCreateMode ) {
			continue;
		}

		if ( es.SubObjectOf != null ) {
			subPropMap[es.SubObjectOf].Add(es);
			continue;
		}

		keepEdges.Add(es);
		OutputVertexProp(es, pCreateMode);
	}
	
	foreach ( string sub in subMap.Keys ) {
		//bool isSubNul = v.IsSubObjectNullable(sub);
#>
		public <#= apiNamePrefix+sub #> <#= sub.Substring(3) #> { get; set; }
<#+	
	} // end subMap loop

	if ( pCreateMode ) {
		OutputVertexValidate(v, props, keepEdges);
	}
	else {
		OutputVertexFill(v);
	}
#>

	}
<#+
	foreach ( string sub in subMap.Keys ) {
#>


	/*================================================================================================*/
	public class <#= apiNamePrefix+sub #> : <#= subBaseName #> {

<#+
	props = subMap[sub];
	edges = subPropMap[sub];

	foreach ( ApiProperty ap in props ) {
		OutputVertexProp(ap, pCreateMode);
	}

	foreach ( IEdgeSchema es in edges ) {
		OutputVertexProp(es, pCreateMode);
	}
			
	if ( pCreateMode ) {
		OutputVertexValidate(v, props, edges);
	}
#>

	}
<#+
	} //end subMap loop
}


public void OutputVertexProp(ApiProperty pProp, bool pCreateMode) {
	OutputVertexProp(pProp.GetDataTypeName(), pProp.Name, (pCreateMode ? pProp.CreateAccess+"" : null));
}


public void OutputVertexProp(IEdgeSchema pEdge, bool pCreateMode) {
	OutputVertexProp("long"+(pEdge.GetIsOptional() ? "?" : ""), pEdge.GetPropNameApi(),
			(pCreateMode ? pEdge.FabToVertexId.CreateAccess+"" : null));
}


public void OutputVertexProp(string pType, string pName, string pCreateAccess) {
#>
		public virtual <#= pType #> <#= pName #> { get; set; }
<#+
}


public void OutputVertexFill(IVertexSchema pVertex) {
#>


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override void Fill(Vertex pVertex) {
			DomainToApi.From<#= pVertex.Names.Domain #>(this, (<#= pVertex.Names.Domain #>)pVertex);
		}

		/*--------------------------------------------------------------------------------------------*/
		public static <#= pVertex.Names.Api #> From<#= pVertex.Names.Domain #>(<#= pVertex.Names.Domain #> pVertex) {
			var v = new <#= pVertex.Names.Api #>();
			v.Fill(pVertex);
			return v;
		}
<#+
}


public void OutputVertexValidate(IVertexSchema pVertex, IList<ApiProperty> pProps, IList<IEdgeSchema> pEdges) {
#>


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override void Validate() {
			base.Validate();
<#+
		
	foreach ( ApiProperty ap in pProps ) {
		string displayName = (ap.SubObjectOf == null ? "" : ap.SubObjectOf.Substring(3)+".")+ap.Name;
#>

			//Validate <#= ap.Name #>
<#+
		if ( !ap.IsNullable && ap.DataType == typeof(string) ) {
#>
			NotNull("<#= displayName #>", <#= ap.Name #>);
<#+
		}

		if ( ap.LenMin != null ) {
#>
			LenMin("<#= displayName #>", <#= ap.Name #>, <#= ap.LenMin #>);
<#+
		}

		if ( ap.LenMax != null ) {
#>
			LenMax("<#= displayName #>", <#= ap.Name #>, <#= ap.LenMax #>);
<#+
		}

		if ( ap.ValidRegex != null ) {
#>
			ValidRegex("<#= displayName #>", <#= ap.Name #>,
				@"<#= ap.ValidRegex.Replace("\"", "\"\"") #>");
<#+
		}

		if ( ap.FromEnum != null ) {
#>
			ValidEnum<<#= ap.FromEnum #>.Id>("<#= displayName #>", <#= ap.Name #>);
<#+
		}
			
		if ( ap.CustomValidation ) {
			string funcName = pVertex.Names.Domain+
				(ap.SubObjectOf == null ? "" : ap.SubObjectOf.Substring(3))+ap.Name;
#>
			ApiVerticesCustom.Validate<#= funcName #>(this, "<#= displayName #>", <#= ap.Name #>);
<#+
		}

	} //end property loop
#>

			//Validate edges
<#+
	foreach ( IEdgeSchema es in pEdges ) {
		string displayName = (es.SubObjectOf == null ? "" :	es.SubObjectOf.Substring(3)+".")+
			es.GetPropNameApi();
#>
			ValidVertexId("<#= displayName #>", <#= es.GetPropNameApi() #>);
<#+
	}
#>
		}
<#+
}
#>