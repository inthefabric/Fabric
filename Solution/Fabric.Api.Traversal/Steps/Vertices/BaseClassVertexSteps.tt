<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.5.4\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using System.Linq;
using Fabric.Api.Dto.Traversal;
using Fabric.Infrastructure.Traversal;
using Fabric.Infrastructure.Weaver;

namespace Fabric.Api.Traversal.Steps.Vertices {
	
<#
IList<string> vertexNames = SchemaHelper.GetVertices();

foreach ( string name in vertexNames ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;

	if ( !vertex.IsBaseClass || vertex.IsInternal ) {
		continue;
	}

	IList<SchemaHelperVertexEdge> vertexEdges = hn.GetEdges(true);
	var linkEdges = new List<SchemaHelperVertexEdge>();
	string typeIdIsLong = "false";
	
	foreach ( WeaverPropSchema prop in vertex.Props ) {
		if ( prop.Name != vertex.Name+"Id" ) { continue; }
		typeIdIsLong = (prop.Type == typeof(long) ? "true" : "false");
		break;
	}
	
	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		if ( vertex.Name != "Root" && hr.OutVertexName == "Root" ) { continue; }
		linkEdges.Add(hr);
	}
#>

	/*================================================================================================*/
	public abstract partial class <#= vertex.Name #>Step<T> : VertexStep<T>, I<#= vertex.Name #>Step
																			where T : FabVertex, new() {
		

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		protected <#= vertex.Name #>Step(IPath pPath) : base(pPath) {
			ConstructorHook();
		}
		
		/*--------------------------------------------------------------------------------------------*/
		partial void ConstructorHook();
<#
	if ( !vertex.IsAbstract ) {
#>

		/*--------------------------------------------------------------------------------------------*/
		public override List<IStepLink> AvailableLinks {
			get { return base.AvailableLinks.Concat(<#= vertex.Name #>Step.AvailVertexLinks).ToList(); }
		}
		
		/*--------------------------------------------------------------------------------------------*/
		public override string TypeIdName { get { return PropDbName.Artifact_ArtifactId; } }
		public override bool TypeIdIsLong { get { return true; } }

<#
	} //end abstract condition

	if ( linkEdges.Count > 0 ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override IStep GetLink(StepData pData) {
			switch ( pData.Command ) {
<#
		foreach ( SchemaHelperVertexEdge hr in linkEdges ) {
			var propName = hr.EdgePropName;
#>
				case "<#= propName.ToLower() #>": return <#= propName #>;
<#
		} //end vertexEdges loop
#>
			}

			return base.GetLink(pData);
		}
<#
	} //end linkEdges condition
#>

<#
	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		var propType = hr.TargetVertexType+"Step";
		var script = (hr.IsOutgoing ? "outE" : "inE")+"('"+hr.EdgeSchema.DbName+"')."+
			(hr.IsOutgoing ? "inV" : "outV");
#>
		/*--------------------------------------------------------------------------------------------*/
		public I<#= propType #> <#= hr.EdgePropName #> {
			get {
				var step = new <#= propType #>(Path);
				Path.AddSegment(step, "<#= script #>");
				return step;
			}
		}

<#
	} //end vertexEdges loop
#>
	}

<#
	if ( vertex.IsAbstract ) {
		continue;
	}
#>

	/*================================================================================================*/
	public partial class <#= vertex.Name #>Step : <#= vertex.Name #>Step<Fab<#= vertex.Name #>> {
	
		internal static readonly List<IStepLink> AvailVertexLinks = new List<IStepLink> {
<#
	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		if ( vertex.Name != "Root" && hr.OutVertexName == "Root" ) { continue; }
#>
			new StepLink("<#= hr.EdgeTypeName #>", "<#= hr.TargetVertexType #>", <#= hr.IsOutgoing.ToString().ToLower() #>, "/<#= hr.EdgePropName #>"),
<#
	}
#>
		};


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= vertex.Name #>Step(IPath pPath) : base(pPath) {
			ConstructorHook();
		}
		
		/*--------------------------------------------------------------------------------------------*/
		partial void ConstructorHook();
		
		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public override string TypeIdName { get { return PropDbName.<#= vertex.Name #>_<#= vertex.Name #>Id; } }
		public override bool TypeIdIsLong { get { return <#= typeIdIsLong #>; } }

	}

<#
} //end verts loop
#>
}