<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.5.0\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;

namespace Fabric.Test.Util {
	
	/*================================================================================================*/
	public static class StepUtil {

		public static Dictionary<string, string[]> VertexStepMap = BuildVertexStepMap();
		

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		private static Dictionary<string, string[]> BuildVertexStepMap() {
			var map = new Dictionary<string, string[]>();
			
<#
IList<string> verts = SchemaHelper.GetVertices();

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsAbstract || vertex.IsInternal ) { continue; }

	IList<SchemaHelperVertexEdge> vertexEdges = hn.GetNestedEdges(true);
#>
			map.Add("<#= vertex.Name #>", new string [] {
<#
	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		if ( vertex.Name != "Root" && hr.OutVertexName == "Root" ) { continue; }
#>
				"/<#= hr.EdgePropName #>",
<#
	} //end vertexEdges loop
#>
			});

<#
}
#>
			return map;
		}
		
<#

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsAbstract || vertex.IsInternal ) { continue; }
#>
		/*--------------------------------------------------------------------------------------------* /
		[Test]
		public void <#= vertex.Name #>Step() {
			TestStep("<#= vertex.Name #>", PropDbName.<#= vertex.Name #>_<#= vertex.Name #>Id, tn => new <#= vertex.Name #>Step(tn));
		}*/

<#
}
#>
	}

}