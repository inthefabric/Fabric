<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.0.4.0\lib\Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.Titan.0.4.0\lib\Weaver.Titan.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta\bin\Debug\Fabric.Domain.Meta.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Infrastructure\bin\Debug\Fabric.Infrastructure.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Api.Dto\bin\Debug\Fabric.Api.Dto.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Api.Traversal\bin\Debug\Fabric.Api.Traversal.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Fabric.Api.Dto" #>
<#@ import namespace="Fabric.Api.Dto.Traversal" #>
<#@ import namespace="Fabric.Api.Traversal.Steps.Functions" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Fabric.Infrastructure.Domain.Types" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using Fabric.Api.Dto.Meta;
using Fabric.Infrastructure.Domain.Types;

namespace Fabric.Api.Meta {

	/*================================================================================================*/
	public static class SpecBuilder {
		

		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void FillSpecValue(string pTypeName, string pPropName, FabSpecValue pValue) {
			switch ( pTypeName+"."+pPropName ) {
<#
IList<string> verts = SchemaHelper.GetVertices();
string fabApiDtoNamespace = typeof(FabVertex).AssemblyQualifiedName;

foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;

	string baseVertex = "Fab"+(hn.HasParentClass ? vertex.BaseVertex.Name : "Vertex");
	IList<SchemaHelperProp> props = hn.GetProps(false);

	foreach ( SchemaHelperProp hp in props ) {
		WeaverPropSchema prop = hp.PropSchema;
		string propName = prop.Name;
		string propItems = "";
		string lineEnd = "\r\n\t\t\t\t\t";
		
		if ( prop.Len != null ) {
			propItems += "pValue.Len = "+prop.Len+";"+lineEnd;
		}

		if ( prop.LenMax != null ) {
			propItems += "pValue.LenMax = "+prop.LenMax+";"+lineEnd;
		}

		if ( prop.LenMin != null ) {
			propItems += "pValue.LenMin = "+prop.LenMin+";"+lineEnd;
		}

		if ( prop.ValidRegex != null ) {
			propItems += "pValue.ValidRegex = @\""+prop.ValidRegex.Replace("\"", "\"\"")+"\";"+lineEnd;
		}

#>

				case "<#= vertex.Name #>.<#= propName #>":
					<#= propItems #>break;
<#
	} //end prop loop
} // end vertex loop
#>
			}
		}

		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void FillSpecDtoProp(string pTypeName, string pPropName, FabSpecObjectProp pProp){
			FillSpecValue(pTypeName, pPropName, pProp);

			switch ( pTypeName+"."+pPropName ) {
<#
foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsInternal ) { continue; }

	string baseVertex = "Fab"+(hn.HasParentClass ? vertex.BaseVertex.Name : "Vertex");
	IList<SchemaHelperProp> props = hn.GetProps(true);

	foreach ( SchemaHelperProp hp in props ) {
		FabricPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string vertexName = vertex.Name;
		string propItems = "";
		string lineEnd = "\r\n\t\t\t\t\t";

		if ( hp.IsSubProp() ) {
			int subI = propName.IndexOf('_');
			vertexName = propName.Substring(0, subI);
			propName = propName.Substring(subI+1);
		}
		
		if ( prop.IsCaseInsensitive != null ) {
			propItems += "pProp.IsCaseInsensitive = "+prop.IsCaseInsensitive.ToString().ToLower()+";"+lineEnd;
		}
		
		if ( prop.ToLowerCase ) {
			propItems += "pProp.ToLowerCase = "+prop.ToLowerCase.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsNullable != null ) {
			propItems += "pProp.IsNullable = "+prop.IsNullable.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsPrimaryKey != null ) {
			propItems += "pProp.IsPrimaryKey = "+prop.IsPrimaryKey.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsTimestamp != null ) {
			propItems += "pProp.IsTimestamp = "+prop.IsTimestamp.ToString().ToLower()+";"+lineEnd;
		}
		
		if ( prop.IsUnique != null ) {
			propItems += "pProp.IsUnique = "+prop.IsUnique.ToString().ToLower()+";"+lineEnd;
		}

		string resxDesc = (prop.IsPrimaryKey == true ? "Object_TypeId" : vertexName+"_"+propName);
		string enu = "null";
		
		if ( prop.EnumName != null ) {
			enu = prop.EnumName;
			enu = "\""+enu.Substring(0, enu.Length-2)+"\"";
		}
#>

				case "<#= vertexName #>.<#= propName #>":
					pProp.Name = "<#= propName #>";
					pProp.Type = "<#= propType #>";
					pProp.Description = SpecDoc.GetDtoPropText("<#= resxDesc #>");
					pProp.Enum = <#= enu #>;
					<#= propItems #>break;
<#
	} //end prop loop
} // end vertex loop
#>
			}
		}

		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void FillSpecObjectTravFuncs(string pTypeName, FabSpecObject pObject) {
			switch ( pTypeName ) {
<#
foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsInternal ) { continue; }
#>

				case "<#= vertex.Name #>":
<#
	string dtoAqn = fabApiDtoNamespace.Replace("FabVertex", "Fab"+vertex.Name);
	Type dtoType = Type.GetType(dtoAqn);
	List<string> availFuncs = FuncRegistry.GetAvailableFuncs(dtoType, true, false);
	bool first = true;
		
	foreach ( string funcUri in availFuncs ) {
		if ( first ) {
			first = false;
#>
					pObject.TraversalFunctions = new List<string>();
<#
		}
#>
					pObject.TraversalFunctions.Add("<#= funcUri.Substring(1) #>");
<#
	} //end func loop
#>
					break;
<#
} // end vertex loop
#>
			}
		}

		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void FillSpecDtoLinks(string pTypeName, FabSpecObject pObject) {
			FabSpecTravLink link;

			switch ( pTypeName ) {
<#
foreach ( string name in verts ) {
	SchemaHelperVertex hn = SchemaHelper.GetVertex(name);
	WeaverVertexSchema vertex = hn.VertexSchema;
	if ( vertex.IsInternal ) { continue; }
#>

				case "<#= vertex.Name #>":
<#
	
	IList<SchemaHelperVertexEdge> vertexEdges = hn.GetEdges(true);
	bool first = true;

	foreach ( SchemaHelperVertexEdge hr in vertexEdges ) {
		if ( first ) {
			first = false;
#>
					pObject.TraversalLinks = new List<FabSpecTravLink>();

<#
		}
#>
					link = new FabSpecTravLink();
					link.Name = "<#= hr.EdgePropName #>";
					link.Type = "<#= hr.EdgeName #>";
					link.Description = SpecDoc.GetDtoLinkText("<#= hr.EdgeName #>");
					link.IsOutgoing = <#= hr.IsOutgoing.ToString().ToLower() #>;
					link.From = "Fab<#= hr.OutVertexName #>";
					link.FromConn = "<#= hr.EdgeSchema.OutVertexConn+"" #>";
					link.Relation = "<#= hr.EdgeTypeName #>";
					link.To = "Fab<#= hr.InVertexName #>";
					link.ToConn = "<#= hr.EdgeSchema.InVertexConn+"" #>";
					pObject.TraversalLinks.Add(link);

<#
	} //end edge loop
#>
					break;
<#
} // end vertex loop
#>
			}

		}

		
		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static List<FabSpecEnum> BuildSpecEnums() {
			var list = new List<FabSpecEnum>();
			FabSpecEnum e;
			FabSpecObjectProp p;

			e = new FabSpecEnum();
			e.Name = "BaseEnum";
			e.Description = SpecDoc.GetEnumText("BaseEnum");
			e.Properties = new List<FabSpecObjectProp>();
			list.Add(e);
			
<#
PropertyInfo[] baseProps = typeof(BaseType).GetProperties();

foreach ( PropertyInfo prop in baseProps ) {
	Type pt = prop.PropertyType;
#>
				p = new FabSpecObjectProp();
				p.Name = "<#= prop.Name #>";
				p.Description = SpecDoc.GetEnumPropText("BaseEnum_<#= prop.Name #>");
				p.Type = "<#= SchemaHelperProp.GetTypeName(pt) #>";
				e.Properties.Add(p);

<#
}// end baseEnum loop

foreach ( Type type in StaticTypes.TypeList ) {
	PropertyInfo[] props = type.GetProperties(
		BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
#>
			e = new FabSpecEnum();
			e.Name = "<#= type.Name #>";
			e.Description = SpecDoc.GetEnumText("<#= type.Name #>");
			e.Extends = "BaseEnum";
			e.Properties = new List<FabSpecObjectProp>();
			
<#
	foreach ( PropertyInfo prop in props ) {
		Type pt = prop.PropertyType;
#>
				p = new FabSpecObjectProp();
				p.Name = "<#= prop.Name #>";
				p.Description = SpecDoc.GetEnumPropText("<#= type.Name+"_"+prop.Name #>");
				p.Type = "<#= SchemaHelperProp.GetTypeName(pt) #>";
				e.Properties.Add(p);

<#
	} //end prop loop
#>
			e.Data = new List<Dictionary<string, object>>();

			foreach ( <#= type.Name #> val in StaticTypes.<#= type.Name #>s.Values ) {
				var map = new Dictionary<string, object>();
<#
	PropertyInfo[] allProps = type.GetProperties();

	foreach ( PropertyInfo prop in allProps ) {
#>
				map.Add("<#= prop.Name #>", val.<#= prop.Name #>);
<#
	} //end prop loop
#>
				e.Data.Add(map);
			}

			list.Add(e);

<#
} //end type loop
#>
			return list;
		}

	}

}