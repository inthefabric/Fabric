//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.296
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Fabric.Api.Meta.Lang {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class DtoText {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal DtoText() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Fabric.Api.Meta.Lang.DtoText", typeof(DtoText).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A registered project, application, or business that has direct access to the Fabric API.
        ///
        ///An !App&apos;s primary purpose is to facilitate User interaction with Fabric. To accomplish this, an !App typically creates an interface for its Users. This interface hides the complex details of the Fabric API, and instead provides intuitive features like custom inputs, searches, summaries, and visualizations. 
        ///
        ///When a User becomes a Member of an !App, they are granting that !App permission to perform various actions o [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string App {
            get {
                return ResourceManager.GetString("App", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An object which is able to (via Factor connections) accumulate meaning, context, user sentiment, and relationships.  !Artifacts and Factors are the central components of the Fabric architecture.
        ///
        ///There are no restrictions on what an !Artifact can represent.  Fabric encourages the generous use of Factors to identify and describe each new !Artifact. Ideally, the Factor connections will distinguish an !Artifact from all others..
        /// </summary>
        internal static string Artifact {
            get {
                return ResourceManager.GetString("Artifact", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides input data for batch Class creation. See the Class and [[AddClass operation|Oper|Modify.AddClass]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewClass {
            get {
                return ResourceManager.GetString("BatchNewClass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides input data for batch Factor creation. See the Factor and [[AddFactor operation|Oper|Modify.AddFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactor {
            get {
                return ResourceManager.GetString("BatchNewFactor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Descriptor input data for batch Factor creation. See the Descriptor and [[AttachDescriptor operation|Oper|Modify.AttachDescriptorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorDescriptor {
            get {
                return ResourceManager.GetString("BatchNewFactorDescriptor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Director input data for batch Factor creation. See the Director and [[AttachDirector  operation|Oper|Modify.AttachDirectorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorDirector {
            get {
                return ResourceManager.GetString("BatchNewFactorDirector", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Eventor input data for batch Factor creation. See the Eventor and [[AttachEventor operation|Oper|Modify.AttachEventorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorEventor {
            get {
                return ResourceManager.GetString("BatchNewFactorEventor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Identor input data for batch Factor creation. See the Identor and [[AttachIdentor operation|Oper|Modify.AttachIdentorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorIdentor {
            get {
                return ResourceManager.GetString("BatchNewFactorIdentor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Locator input data for batch Factor creation. See the Locator and [[AttachLocator operation|Oper|Modify.AttachLocatorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorLocator {
            get {
                return ResourceManager.GetString("BatchNewFactorLocator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides Vector input data for batch Factor creation. See the Vector and [[AttachVector operation|Oper|Modify.AttachVectorToFactor]] documentation for details and parameter restrictions..
        /// </summary>
        internal static string BatchNewFactorVector {
            get {
                return ResourceManager.GetString("BatchNewFactorVector", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TODO.
        /// </summary>
        internal static string BatchNewObject {
            get {
                return ResourceManager.GetString("BatchNewObject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to TODO.
        /// </summary>
        internal static string BatchResult {
            get {
                return ResourceManager.GetString("BatchResult", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Represents any item (real, imaginary, virtual, conceptual, or otherwise) that an App or User can define and/or use to generate meaning. !Classes and Instances are closely related, and are the primary method for generating new Artifacts.
        ///
        ///A !Class represents a particular group, type, set, or category of items. Each !Class must uniquely identifiable (via name and disambiguation) amonst all other !Classes.
        ///[(EX|Ellie&apos;s Class Example|Ellie is building an App for dog lovers, but there are not yet animal-relat [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Class {
            get {
                return ResourceManager.GetString("Class", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A group or collection of Users. The members of a !Crowd are called Crowdians.
        ///
        ///A !Crowd can be public or private. A public !Crowd and its Crowdians are accessible to all Apps and Users. A private !Crowd (also called a &apos;Circle&apos;) is only accessible to the User who created it.
        ///
        ///A public !Crowd can be open or restricted. An open !Crowd does not require an invitation to join.  A restricted !Crowd requires an invitation.
        ///
        ///!Crowds are useful on many levels, as they:
        ///- allow like-minded Users to connect and  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Crowd {
            get {
                return ResourceManager.GetString("Crowd", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A User who is a member of a particular Crowd. The Crowd administrator(s) can grant various access privileges to a !Crowdian by adjusting its CrowdianType.
        ///
        ///If desired, the Crowd administrator(s) can also apply a weighting value to each !Crowdian. When performing data analysis on a Crowd, this value allows each !Crowdian to have a different level of impact on the results. A high weighting value equates to high Crowdian imact.
        ///
        ///There are various restrictions (based on Crowd properties) for !Crowdian creat [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Crowdian {
            get {
                return ResourceManager.GetString("Crowdian", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Describes and refines the relationship between the two Artifacts of a particular Factor.
        ///
        ///The primary purpose of a !Descriptor is to describe the relationship between a Factor&apos;s primary Artifact and related Artifact. The DescriptorType provides this description, establishing meaningful connections like a A &apos;is a&apos; B, or C &apos;sounds like&apos; D.
        ///
        ///The Artifact relationship (defined by a Factor) is directional, flowing from the primary Artifact to the related Artifact. The DescriptorType, therefore, must coordina [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Descriptor {
            get {
                return ResourceManager.GetString("Descriptor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Creates a directional, action-based pathway between the two Artifacts of a particular Factor.
        ///
        ///The nature of a !Director&apos;s pathway depends on its DirectorType. The !Director can  represent a factual, well-defined path, a virtual link, a suggested flow, etc.
        ///
        ///A !Director specifies a DirectorAction for each of the Factor&apos;s Artifacts, which give additional meaning to the !Director&apos;s pathway. The primary action is meant to be performed on the primary Artifact before the pathway begins. The related action is [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Director {
            get {
                return ResourceManager.GetString("Director", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Describes an action to be taken (via Director) on one of the two Artifacts in a particular Factor. Example actions include: Read, Learn, Obtain, etc..
        /// </summary>
        internal static string DirectorAction {
            get {
                return ResourceManager.GetString("DirectorAction", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a fault or error occurs, a !FabError is returned in place of the expected response data. The information it provides should help determine what caused the issue for the given request..
        /// </summary>
        internal static string Error {
            get {
                return ResourceManager.GetString("Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Applies the concept of time to a particular Factor.
        ///
        ///An !Eventor places a Factor at a specific point in time and describes why it is significant to the Factor. The EventorType provides this significance, establishing that this particular point in time is when the Factor started, occurred, is expected, etc.
        ///
        ///Each !Eventor represents one particular point in time, however, the precision of that point in time can vary. The EventorPrecision allows a point in time to specify a level of accuracy ranging from o [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Eventor {
            get {
                return ResourceManager.GetString("Eventor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides a specific piece of information, knowledge, or opinion about a pair of Artifacts. !Factors and Artifacts are the central components of the Fabric architecture.
        ///
        ///A !Factor forms a directional relationship from its primary Artifact to its related Artifact. There are various !Factor-related components (known as !Factor Elements) available. Each has a specific ability to refine, describe, and/or supplement this Artifact relationship in a meaningful way.
        ///
        ///The six !Factor Elements are called Descript [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Factor {
            get {
                return ResourceManager.GetString("Factor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Describes the type of information (and/or level of confidence) provided by a particular Factor. Example assertions include: Fact, Opinion, Guess, etc..
        /// </summary>
        internal static string FactorAssertion {
            get {
                return ResourceManager.GetString("FactorAssertion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The base class for all Fault objects..
        /// </summary>
        internal static string Fault {
            get {
                return ResourceManager.GetString("Fault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The complete collection of Fabric API services..
        /// </summary>
        internal static string Home {
            get {
                return ResourceManager.GetString("Home", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Applies a name or identifier to a particular Factor.
        ///
        ///An !Identor attaches a text-based value to a Factor. This value can represent a a full name, a nickname, a globally-unique identifier, a reference key to some other system, etc.
        ///
        ///The IdentorType hints at the purpose or intent of the !Identor. A &apos;Text&apos; IdentorType is typically meant to provide enhanced search capabilities (like finding a person by an alternate name) or some other organizational use.  A &apos;Key&apos; IdentorType is typically meant to associate [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Identor {
            get {
                return ResourceManager.GetString("Identor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Represents any item (real, imaginary, virtual, conceptual, or otherwise) that an App or User can define and/or use to generate meaning. Classes and !Instances are closely related, and are the primary method for generating new Artifacts.
        ///
        ///An !Instance represents a singular, unique item. It may have a specific name, however, the name is not required to be unique. Instead, the creator should apply Factors to make the Instance as specific and meaningful as possible.
        ///[(EX|Ellie&apos;s Instance Example|_Continued f [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Instance {
            get {
                return ResourceManager.GetString("Instance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A word, phrase, code, or other text-based value.
        ///
        ///!Labels are less formal (and less effective) than a Class or Instance, and should only be used in certain circumstances.  For example, some value or code (like &apos;A-1234&apos; or &apos;study for science test&apos;) might have a useful purpose for a particular User..
        /// </summary>
        internal static string Label {
            get {
                return ResourceManager.GetString("Label", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Positions a Factor using geographic or relative coordinates.
        ///
        ///A !Locator attaches a three-dimensional coordinate to a Factor. The LocatorType defines the spatial context of the coordinate, supporting both geographic and relative positioning.
        ///
        ///Geographic coordinates represent a position on a sphere, like Earth.  They use X for longitude, Y for latitude, and Z for elevation (in metres above sea level). Use zero for elevation if it is not known or specified.
        ///[(EX|Geographic Example|_Objective:_
        ///Specify t [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Locator {
            get {
                return ResourceManager.GetString("Locator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An association between a User and an App. The App administrator(s) can grant various access privileges to a !Member by adjusting its MemberType.
        ///
        ///Every item added to Fabric is associated with a particular !Member. Thus, Fabric can determine which App or User is responsible for any particular item, enforce applicable access rights, analyze the data for a particular App and/or User, etc..
        /// </summary>
        internal static string Member {
            get {
                return ResourceManager.GetString("Member", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An assignment of a MemberType to a target Member. This action is performed by some Member, which is usually (but not always) different from the target Member. Each Member maintains one active MemberTypeAssign and a list of historical MemberTypeAssigns..
        /// </summary>
        internal static string MemberTypeAssign {
            get {
                return ResourceManager.GetString("MemberTypeAssign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Contains the current Fabric system time. Fabric uses the UTC timezone for all dates, times, and timestamps..
        /// </summary>
        internal static string MetaTime {
            get {
                return ResourceManager.GetString("MetaTime", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Contains the current Fabric version information. Fabric uses semantic versioning..
        /// </summary>
        internal static string MetaVersion {
            get {
                return ResourceManager.GetString("MetaVersion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The base class for all nodes present in the Fabric &quot;graph&quot;.  Only Nodes are present and traversable via the [[Traversal Service|Serv|Traversal]]..
        /// </summary>
        internal static string Node {
            get {
                return ResourceManager.GetString("Node", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The base class for various &quot;actions&quot; that can occur..
        /// </summary>
        internal static string NodeForAction {
            get {
                return ResourceManager.GetString("NodeForAction", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provides an OAuth access token and other related information. Every Fabric API request requires an access token. To include an OAuth access token with a FabricAPI request, add an &quot;Authorization&quot; header to the HTTP request with a value of &quot;Bearer=[your OAuth access code here]&quot;..
        /// </summary>
        internal static string OauthAccess {
            get {
                return ResourceManager.GetString("OauthAccess", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To comply with the OAuth 2.0 specification, all Fabric OAuth requests return a FabOauthError (instead of FabFault or FabError) when errors occur..
        /// </summary>
        internal static string OauthError {
            get {
                return ResourceManager.GetString("OauthError", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This object is unique -- the API never returns this object directly. Instead, the properties shown below are included as query-string parameters for a redirect URI. This URI is provided by an App, and the App is responsible for accepting (and reacting to) the incoming redirect.
        ///
        ///This redirect is used in one particular scenario: the [[OAuth login process|Oper|Oauth.Login]]. After the user completes this process, Fabric performs a redirect with success or failure information.  The success redirect includes  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string OauthLogin {
            get {
                return ResourceManager.GetString("OauthLogin", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The result of an OAuth logout..
        /// </summary>
        internal static string OauthLogout {
            get {
                return ResourceManager.GetString("OauthLogout", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The base class for all !Objects returned by Fabric&apos;s services..
        /// </summary>
        internal static string Object {
            get {
                return ResourceManager.GetString("Object", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The response wrapper for all API requests. It contains a data payload, error information, and/or other metadata..
        /// </summary>
        internal static string Response {
            get {
                return ResourceManager.GetString("Response", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Represents the root, or starting point, of all [[Traversal Service|Serv|Traversal]] queries. The !Root provides traversal links to all other available objects..
        /// </summary>
        internal static string Root {
            get {
                return ResourceManager.GetString("Root", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A collection of ServiceOperations which all share a similar purpose..
        /// </summary>
        internal static string Service {
            get {
                return ResourceManager.GetString("Service", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A task, query, or operation that belongs to a Service..
        /// </summary>
        internal static string ServiceOperation {
            get {
                return ResourceManager.GetString("ServiceOperation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Contains all the relevant information about a Node&apos;s traversal link..
        /// </summary>
        internal static string StepLink {
            get {
                return ResourceManager.GetString("StepLink", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A hyperlink or path (uniform resource locator) to some web page, a file, or some other type of content.
        ///
        ///While a !Url is a type of Artifact, it should be used with certain constraints. Consider an scenario where a !Url leads to web page with a news article and a photo. The proper prodedure is to create a new Instance for both the news article and photo. With this method:
        ///- The news article and photo Instances can receive Factors independently.
        ///- The !Url should only receive Factors related to the actual [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Url {
            get {
                return ResourceManager.GetString("Url", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A registered Fabric account that has indirect access (via Apps) to the Fabric API. A !User can become a Member of an App, and then use the App&apos;s interface to interact with Fabric. An App&apos;s interface hides the complex details of the Fabric API, and instead provides intuitive features like custom inputs, searches, summaries, and visualizations. 
        ///
        ///!Users control their private account data and preferences using the Fabric website.
        ///
        ///Every item added to Fabric is associated with (via Member) a !User and and a [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string User {
            get {
                return ResourceManager.GetString("User", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Applies a meaningful numeric axis and value to a particular Factor.
        ///
        ///A !Vector attaches a numeric value to a Factor, using an arbitrary Artifact to define its &apos;axis&apos;. This axis depends entirely upon the !Vector&apos;s purpose. For example, a factual !Vector might use an Artifact like &apos;Height&apos; or &apos;Shutter Speed&apos;. A !Vector that provides an opinion might use an Artifact like &apos;Quality&apos; or &apos;Excitement&apos;. While the choice of an axis Artififact is not restricted, it can be beneficial to use Artifacts which are other  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Vector {
            get {
                return ResourceManager.GetString("Vector", resourceCulture);
            }
        }
    }
}
