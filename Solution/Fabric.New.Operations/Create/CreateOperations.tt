<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Fabric.New.Domain.Schemas\bin\Debug\Fabric.New.Domain.Schemas.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Edges" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Utils" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Vertices" #>
<#@ output extension=".cs" #>

// GENERATED CODE
// Changes made to this source file will be overwritten

using Fabric.New.Api.Objects;
using Fabric.New.Api.Objects.Conversions;
using Fabric.New.Domain;
using Fabric.New.Infrastructure.Faults;
using Fabric.New.Infrastructure.Query;
using Weaver.Core.Query;

namespace Fabric.New.Operations.Create {
<#
IList<IVertexSchema> vertexSchemas = SchemaUtil.GetVertexSchemas();

foreach ( IVertexSchema v in vertexSchemas ) {
	IVertexSchema vp = SchemaUtil.GetVertexParent(v);
	string baseName = (vp == null ? "CreateOperationBase" : "Create"+vp.Names.Domain+"Operation");
	string createObjName = "Create"+v.Names.Api;
	IList<DomainProperty> props = SchemaUtil.GetVertexDomainProperties(v);
	bool isInternal = v.IsSpecInternal(v.CreateAccess);
	string apiType = (isInternal && v.IsSpecInternal(v.GetAccess) && vp != null ? vp : v).Names.Api;

	bool hasUniqueChecks = false;

	foreach ( DomainProperty dp in props ) {
		if ( dp.EnforceUnique ) {
			hasUniqueChecks = true;
			break;
		}
	}

	if ( v.IsAbstract ) {
#>


	/*================================================================================================*/
	public abstract class Create<#= v.Names.Domain #>Operation<TDom, TApi, TCre> : 
								<#= baseName #><TDom, TApi, TCre> where TDom : <#= v.Names.Domain #>, new()
								where TApi : <#= v.Names.Api #> where TCre : Create<#= v.Names.Api #> {


		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	OutputCreateEdges(v, vp);
#>

	}
<#
		continue;
	} //end "IsAbstract" condition
#>


	/*================================================================================================*/
	public <#= v.CustomCreate ? "partial " : "" #>class Create<#= v.Names.Domain #>Operation : <#= baseName #><<#= v.Names.Domain #>, <#= apiType #>, Create<#= v.Names.Api #>> {
		

		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	if ( v.CustomCreate ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void VerifyCustom() {
			VerifyCustom<#= v.Names.Domain #>();
		}

<#
	} //end "CustomCreate" condition
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override <#= v.Names.Domain #> ToDomain(Create<#= v.Names.Api #> pCreateObj) {
			return ApiToDomain.From<#= createObjName #>(pCreateObj);
		}
<#
	if ( !isInternal ) {
#>

		/*--------------------------------------------------------------------------------------------*/
		protected override <#= v.Names.Api #> ToApi(<#= v.Names.Domain #> pDomainObj) {
			return DomainToApi.From<#= v.Names.Domain #>(pDomainObj);
		}
<#
	} //end "isInternal" condition
#>


		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	if ( hasUniqueChecks ) {
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void CheckForDuplicates() {
			IWeaverVarAlias alias;
<#
	foreach ( DomainProperty dp in props ) {
		if ( dp.EnforceUnique ) {
			string displayName = (dp.Name == "NameKey" ? "Name" : dp.Name); //ugly special case
#>

			IWeaverQuery q = Weave.Inst.Graph
				.V.ExactIndex<<#= v.Names.Domain #>>(x => x.<#= dp.Name #>, NewDom.<#= dp.Name #>)
				.ToQueryAsVar("unq", out alias);
			DataAcc.AddQuery(q, true);
			DataAcc.AppendScriptToLatestCommand("("+alias.Name+"?0:1);");
			string cmdId = SetupLatestCommand(false, true);

			Checks.Add(new DataResultCheck(cmdId, (dr, i) => {
				if ( dr.ToIntAt(i, 0) != 0 ) {
					throw new FabDuplicateFault(typeof(<#= v.Names.Domain #>), "<#= displayName #>", NewCre.<#= displayName #>);
				}
			}));
<#
		} //end EnforceUnique condition
	} //end props loop
#>
		}

<#
	} //end "hasUniqueChecks" condition
#>
		/*--------------------------------------------------------------------------------------------*/
		protected override void AddEdges() {
			Add<#= v.Names.Domain #>Edges(NewDomAlias);
		}

<#
	OutputCreateEdges(v, vp);
#>

	}
<#
} // end verts loop
#>

}
<#+
private void OutputCreateEdges(IVertexSchema pVertex, IVertexSchema pParent) {
	IList<IEdgeSchema> edges = SchemaUtil.GetEdgeSchemasForVertex(pVertex, true);
#>
		/*--------------------------------------------------------------------------------------------*/
		<#= pVertex.IsAbstract ? "protected" : "private" #> void Add<#= pVertex.Names.Domain #>Edges(IWeaverVarAlias<<#= pVertex.Names.Domain #>> pAlias) {
<#+
	if ( pParent != null ) {
#>
			Add<#= pParent.Names.Domain #>Edges(new WeaverVarAlias<<#= pParent.Names.Domain #>>(pAlias.Name));
<#+
	} //end parent condition

	foreach ( IEdgeSchema e in edges ) {
		IVertexSchema fv = SchemaUtil.GetVertex(e.FromVertexType);
		IVertexSchema tv = SchemaUtil.GetVertex(e.ToVertexType);
		string idProp = (e.SubObjectOf == null ? "" : e.SubObjectOf.Substring(3)+".")+
			e.GetPropNameApi();

		if ( SchemaUtil.GetEdgeProperties(e).Count > 0 ) {
			throw new Exception("Edge should not have properties: "+e.NameDom);
		}
#>

			////
			
			IWeaverVarAlias<<#= tv.Names.Domain #>> <#= e.NameDb #>Alias =
				AddEdge<<#= fv.Names.Domain #>, <#= e.GetClassNameDom() #>, <#= tv.Names.Domain #>>(
					pAlias, NewCre.<#= idProp #>);
<#+

		IEdgeSchema opp = SchemaUtil.GetReverseEdgeSchema(pVertex, e);

		if ( opp == null ) {
			continue;
		}
#>

			var <#= opp.NameDb #>Edge = new <#= opp.GetClassNameDom() #>();
<#+
		IList<EdgeProperty> edgeProps = SchemaUtil.GetEdgeProperties(opp);

		foreach ( EdgeProperty ep in edgeProps ) {
			IEdgeSchema edgeToProp = ep.GetEdgeToDomainProp();
			DomainProperty dp = ep.GetDomainProp();
			string fromVar = (edgeToProp == null ?
				"NewDom."+dp.Name : "NewCre."+edgeToProp.GetPropNameApi());
#>
			<#= opp.NameDb #>Edge.<#= ep.Name #> = <#= fromVar #>;
<#+
		}
#>

			AddReverseEdge(<#= e.NameDb #>Alias, <#= opp.NameDb #>Edge, pAlias);
<#+
	} //end edges loop
#>
		}
<#+
} //end function
#>