<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Fabric.New.Domain.Schemas\bin\Debug\Fabric.New.Domain.Schemas.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Edges" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Utils" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Vertices" #>
<#@ output extension=".cs" #>

// GENERATED CODE
// Changes made to this source file will be overwritten

using Fabric.New.Api.Objects;
using Fabric.New.Api.Objects.Conversions;
using Fabric.New.Domain;
using Fabric.New.Infrastructure.Query;
using Weaver.Core.Query;

namespace Fabric.New.Operations.Create {
<#
IList<IVertexSchema> vertexSchemas = SchemaUtil.GetVertexSchemas();

foreach ( IVertexSchema v in vertexSchemas ) {
	IVertexSchema vp = SchemaUtil.GetVertexParent(v);
	string baseName = (vp == null ? "CreateOperationBase" : "Create"+vp.Names.Domain+"Operation");

	IList<IEdgeSchema> edges = SchemaUtil.GetEdgeSchemasForVertex(v, true);
	string createObjName = "Create"+v.Names.Api;

	if ( v.IsAbstract ) {
#>


	/*================================================================================================*/
	public abstract class Create<#= v.Names.Domain #>Operation : <#= baseName #> {}
<#
		continue;
	} //end "IsAbstract" condition
#>
			

	/*================================================================================================*/
	public class Create<#= v.Names.Domain #>Operation : <#= baseName #> {
		
		private IWeaverVarAlias<<#= v.Names.Domain #>> vVertexAlias;
		private <#= createObjName #> vCreateObj;
		private <#= v.Names.Domain #> vDomObj;
		private <#= v.Names.Api #> vResult;


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		protected override void SetVertexAlias<T>(IWeaverVarAlias<T> pAlias) {
			base.SetVertexAlias(pAlias);
			vVertexAlias = (IWeaverVarAlias<<#= v.Names.Domain #>>)pAlias;
		}

		/*--------------------------------------------------------------------------------------------*/
		public <#= v.Names.Api #> Get<#= v.Names.Api #>Result() {
			return vResult;
		}

		/*--------------------------------------------------------------------------------------------*/
		public override FabObject GetResult() {
			return vResult;
		}

		/*--------------------------------------------------------------------------------------------*/
		public override void Create(IOperationContext pOpCtx, string pJson) {
			OpCtx = pOpCtx;
			
			<#= createObjName #> input;
			vDomObj = ConvertInput(pJson, ApiToDomain.From<#= createObjName #>, out input);
			vCreateObj = input;
		
			IWeaverVarAlias<<#= v.Names.Domain #>> domVar;
			TxBuild = new TxBuilder();
			TxBuild.AddVertex(vDomObj, out domVar);
			SetVertexAlias(domVar);
			CreateEdges(input);

			//TODO: execute Create<#= v.Names.Domain #> tx

			vResult = DomainToApi.From<#= v.Names.Domain #>(vDomObj);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override void CreateEdges<T>(T pCreateObj) {
			base.CreateEdges(pCreateObj);
<#
	foreach ( IEdgeSchema e in edges ) {
		IVertexSchema fv = SchemaUtil.GetVertex(e.FromVertexType);
		IVertexSchema tv = SchemaUtil.GetVertex(e.ToVertexType);
		string idProp = (e.SubObjectOf == null ? "" : e.SubObjectOf.Substring(3)+".")+
			e.GetPropNameApi();

		if ( SchemaUtil.GetEdgeProperties(e).Count > 0 ) {
			throw new Exception("Edge should not have properties: "+e.NameDom);
		}
#>

			////

			IWeaverVarAlias<<#= tv.Names.Domain #>> <#= e.NameDb #>Alias =
				AddEdge<<#= fv.Names.Domain #>, <#= e.GetClassNameDom() #>, <#= tv.Names.Domain #>>(
					vVertexAlias, vCreateObj.<#= idProp #>);
<#

		IEdgeSchema opp = SchemaUtil.GetReverseEdgeSchema(v, e);

		if ( opp == null ) {
			continue;
		}
#>

			var <#= opp.NameDb #>Edge = new <#= opp.GetClassNameDom() #>();
<#
		IList<EdgeProperty> edgeProps = SchemaUtil.GetEdgeProperties(opp);

		foreach ( EdgeProperty ep in edgeProps ) {
			IEdgeSchema edgeToProp = ep.GetEdgeToDomainProp();
			DomainProperty dp = ep.GetDomainProp();
			string fromVar = (edgeToProp == null ?
				"vDomObj."+dp.Name : "vCreateObj."+edgeToProp.GetPropNameApi());
#>
			<#= opp.NameDb #>Edge.<#= ep.Name #> = <#= fromVar #>;
<#
		}
#>

			AddReverseEdge(<#= e.NameDb #>Alias, <#= opp.NameDb #>Edge, vVertexAlias);
<#
	} //end edges loop
#>
		}

	}
<#
} // end verts loop
#>

}