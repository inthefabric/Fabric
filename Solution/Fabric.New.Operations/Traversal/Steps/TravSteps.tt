<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Fabric.New.Domain.Schemas\bin\Debug\Fabric.New.Domain.Schemas.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Edges" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Utils" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Vertices" #>
<#@ output extension=".cs" #>

// GENERATED CODE
// Changes made to this source file will be overwritten

using System.Collections.Generic;
using Fabric.New.Api.Objects;

namespace Fabric.New.Operations.Traversal.Steps {

	/*================================================================================================*/
	public static class TravSteps {

		public static IList<ITravStep> LinkList = new List<ITravStep> {
<#
IList<IVertexSchema> verts = SchemaUtil.GetVertexSchemas();

foreach ( IVertexSchema v in verts ) {
	if ( v.GetAccess != Access.All ) {
		//continue;
	}

	IList<IEdgeSchema> vertEdges = SchemaUtil.GetEdgeSchemasForVertex(v, false);

	foreach ( IEdgeSchema e in vertEdges ) {
		string link = e.GetPropNameLink();
		string name = v.Names.Domain+link+"Step";
		string fromType = e.GetFromVertex().Names.Api;
		string toType = e.GetToVertex().Names.Api;

		if ( SchemaUtil.GetEdgeProperties(e).Count > 0 ) {
			toType = e.GetClassNameApi(false);
		}
#>
			new TravStepLink<<#= fromType #>, <#= toType #>>("<#= link #>", "<#= e.NameDb #>"),
<#
	} // end edge loop
} // end vertex loop
#>
		};

		public static IList<ITravStep> VertexHasList = new List<ITravStep> {
<#
foreach ( IVertexSchema v in verts ) {
	IDictionary<ApiProperty, PropertyMapping> propMaps = SchemaUtil.GetVertexApiPropertyMaps(v);

	foreach ( ApiProperty ap in propMaps.Keys ) {
		if ( ap.GetAccess != Access.All || ap.TraversalHas == Matching.None ) {
			continue;
		}

		PropertyMapping pm = propMaps[ap];
		string type = ap.GetDataTypeName().Replace("?", "");
		string name = (ap.SubObjectOf == null ? "" : ap.SubObjectOf.Substring(3))+ap.Name;
		string exact = (ap.IsTraversalHasExact()+"").ToLower();

		if ( ap.TraversalHas == Matching.Custom ) {
#>
			TravStepsCustom.Has<#= v.Names.Domain+name #><<#= v.Names.Api #>, <#= type #>>("<#= name #>", "<#= pm.Domain.DbName #>"),
<#
			continue;
		}
#>
			new TravStepHas<<#= v.Names.Api #>, <#= type #>>("<#= name #>", "<#= pm.Domain.DbName #>", <#= exact #>),
<#
	} // end property loop
} // end vertex loop
#>
		};

		public static IList<ITravStep> LinkHasList = new List<ITravStep> {
<#
IList<IEdgeSchema> edges = SchemaUtil.GetEdgeSchemas();

foreach ( IEdgeSchema e in edges ) {
	if ( e.GetFromVertex().GetAccess != Access.All || e.GetToVertex().GetAccess != Access.All ) {
		continue;
	}

	string edgeName = e.GetClassNameApi(false);
	IList<EdgeProperty> props = SchemaUtil.GetEdgeProperties(e);

	foreach ( EdgeProperty p in props ) {
		string type = p.GetDataTypeName();
		string exact = "false";
#>
			new TravStepHas<<#= edgeName #>, <#= type #>>("<#= p.Name #>", "<#= p.DbName #>", <#= exact #>),
<#
	} // end property loop
} // end edge loop
#>
		};

	}

}