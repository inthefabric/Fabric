<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)Fabric.New.Domain.Schemas\bin\Debug\Fabric.New.Domain.Schemas.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Edges" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Utils" #>
<#@ import namespace="Fabric.New.Domain.Schemas.Vertices" #>
<#@ output extension=".cs" #>

// GENERATED CODE
// Changes made to this source file will be overwritten

using Weaver.Core.Query;

namespace Fabric.New.Database.Init.Setups {


	/*================================================================================================*/
	public partial class SetupIndexes {


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public void Create() {
			CreateVerts();
			CreateEdges();
		}

		/*--------------------------------------------------------------------------------------------*/
		private void CreateVerts() {
<#
IList<IVertexSchema> verts = SchemaUtil.GetVertexSchemas();
IList<IEdgeSchema> edges = SchemaUtil.GetEdgeSchemas();

foreach ( IVertexSchema v in verts ) {
	IList<DomainProperty> vertProps = SchemaUtil.GetVertexDomainProperties(v);
#>

			//<#= v.Names.Domain #>
<#
	foreach ( DomainProperty dp in vertProps ) {
		string isUni = (dp.EnforceUnique+"").ToLower();
		string ind = "None";

		if ( dp.IsIndexed && dp.IsElastic ) {
			ind = "Both";
		}
		else if ( dp.IsIndexed ) {
			ind = "Standard";
		}
		else if ( dp.IsElastic ) {
			ind = "Elastic";
		}
#>
			AddProp(Elem.Vertex, "<#= dp.DbName #>", "<#= dp.GetTitanTypeName() #>", Index.<#= ind #>, <#= isUni #>);
<#
	} // end property loop
} // end vertex loop
#>
		}

		/*--------------------------------------------------------------------------------------------*/
		private void CreateEdges() {
<#
foreach ( IEdgeSchema e in edges ) {
#>

			//<#= e.GetClassNameDom() #>
<#
	IList<EdgeProperty> edgeProps = SchemaUtil.GetEdgeProperties(e);
	string cardin = "OneTo"+(e.GetIsMultiple() ? "Many" : "One");
	var sort = new List<string>();
	var sig = new List<string>();
	var order = "None";

	//TODO: investigate signature() more closely:
	//https://github.com/thinkaurelius/titan/wiki/Type-Definition-Overview
	//Probably supposed to use the outgoing VERTEX properties here

	foreach ( EdgeProperty ep in edgeProps ) {
		if ( ep.Sort != EdgeProperty.SortType.None ) {
			if ( sort.Count > 0 ) {
				throw new Exception("Multiple sort keys are not supported.");
			}

			sort.Add(ep.DbName);
			order = ep.Sort+"";
		}
		else {
			sig.Add(ep.DbName);
		}
#>
			AddProp(Elem.Edge, "<#= ep.DbName #>", "<#= ep.GetDataTypeName() #>", Index.Standard, false);
<#
	} // end property loop

	string sortArray = (sort.Count == 0 ? "new string[0]" :
		"new[] {"+string.Join(", ", sort.Select(x => "\""+x+"\""))+"}");
	string sigArray = (sig.Count == 0 ? "new string[0]" :
		"new[] {"+string.Join(",", sig.Select(x => "\""+x+"\""))+"}");
#>
			AddEdge("<#= e.NameDb #>", Cardin.<#= cardin #>, Sort.<#= order #>, <#= sortArray #>, <#= sigArray #>);
<#
} // end edge loop
#>
		}

	}

}