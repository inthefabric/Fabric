<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver\Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Infrastructure\bin\Debug\Fabric.Infrastructure.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Infrastructure" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using Fabric.Api.Dto;

namespace Fabric.Api.Paths.Steps.Nodes {
	
<#
IList<string> nodeNames = SchemaHelper.GetNodes();
var intMap = new Dictionary<string,bool>();

foreach ( string name in nodeNames ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	IList<SchemaHelperNodeRel> nodeRels = hn.GetRels(true);

	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
		if ( intMap.ContainsKey(hr.RelDtoPropName) ) { continue; }
		intMap.Add(hr.RelDtoPropName, true);
#>
	/*================================================================================================*/
	public interface I<#= hr.RelDtoPropName #> {
		<#= hr.TargetNodeType #>Step <#= hr.RelDtoPropName #> { get; }
	}

<#
	} //end nodeRels loop
} //end nodes loop

var schema = new Schema();

foreach ( string name in nodeNames ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverNodeSchema node = hn.NodeSchema;
	if ( node.IsAbstract || node.IsInternal ) { continue; }

	IList<SchemaHelperNodeRel> nodeRels = hn.GetRels(true);
	string interfaces = "";
	string steps = "";

	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
		interfaces += (interfaces == "" ? "" : ", ")+"I"+hr.RelDtoPropName;
		if ( node.Name != "Root" && hr.FromNodeName == "Root" ) { continue; }
		steps += (steps == "" ? "" : ", ")+"\"/"+hr.RelDtoPropName+"\"";
	}
	
	string typeIdIsLong = "false";
	
	foreach ( WeaverPropSchema prop in node.Props ) {
		if ( prop.Name != node.Name+"Id" ) { continue; }
		typeIdIsLong = (prop.Type == typeof(long) ? "true" : "false");
		break;
	}
#>
	/*================================================================================================*/
	public partial class <#= node.Name #>Step : NodeStep<<#= "Fab"+node.Name #>>, <#= interfaces #> {
	
		private static readonly string[] AvailNodeSteps = new [] { <#= steps #> };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>Step(bool pIsToNode, Path pPath) : base(pPath) {
<#
	if ( node.Name == "Root" ) {
#>
			string q;
			
			if ( pPath.Segments.Count == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}
			
			AddPathSegment(q);
<#
	}
	else {
#>
			AddPathSegment(pIsToNode ? "inV" : "outV");
<#
	}
#>
		}

		/*--------------------------------------------------------------------------------------------*/
		public override string TypeIdName { get { return "<#= node.Name #>Id"; } }
		public override bool TypeIdIsLong { get { return <#= typeIdIsLong #>; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailNodeSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailNodeSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IStep GetNextStep(StepData pData) {
			switch ( pData.Command ) {
<#
	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
		if ( node.Name != "Root" && hr.FromNodeName == "Root" ) { continue; }
		var propName = hr.RelDtoPropName;
#>
				case "<#= propName.ToLower() #>": return <#= propName #>;
<#
	} //end nodeRels loop
#>
			}

			return base.GetNextStep(pData);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
		var propType = hr.TargetNodeType+"Step";
		var script = (hr.IsOutgoing ? "outE" : "inE")+"('"+hr.RelName+"')";
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= propType #> <#= hr.RelDtoPropName #> {
			get {
				Path.AppendToCurrentSegment("<#= script #>");
				return new <#= propType #>(<#= (hr.IsOutgoing ? "true" : "false") #>, Path);
			}
		}

<#
	} //end nodeRels loop
#>
	}

<#
} //end nodes loop
#>
}