<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Packages\Weaver\Weaver.dll" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Solution\Fabric.Domain.Schema\bin\Debug\Fabric.Domain.Schema.dll" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Solution\Fabric.Domain\bin\Debug\Fabric.Domain.dll" #>
<#@ assembly name="Z:\Work\AestheticInteractive\FabricProject\Fabric2\Solution\Fabric.Infrastructure\bin\Debug\Fabric.Infrastructure.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="Fabric.Domain" #>
<#@ import namespace="Fabric.Domain.Schema" #>
<#@ import namespace="Fabric.Infrastructure" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using Fabric.Api.Dto;

namespace Fabric.Api.Paths.Steps.Nodes {
	
<#
var schema = new GraphSchema();
var relIntMap = new Dictionary<string, bool>();

foreach ( WeaverRelSchema rel in schema.Rels ) {
	string outName = PathUtil.GetRelInterface(rel, true);
	string inName = PathUtil.GetRelInterface(rel, false);
	
	if ( !relIntMap.ContainsKey(outName) ) {
		relIntMap.Add(outName, true);
#>
	/*================================================================================================*/
	public interface <#= outName #> {
		<#= PathUtil.GetRelPropType(rel, true) #>Step <#= PathUtil.GetRelProp(rel, true) #> { get; }
	}

<#
	}

	if ( !relIntMap.ContainsKey(inName) ) {
		relIntMap.Add(inName, true);
#>
	/*================================================================================================*/
	public interface <#= inName #> {
		<#= PathUtil.GetRelPropType(rel, false) #>Step <#= PathUtil.GetRelProp(rel, false) #> { get; }
	}

<#
	} //end map test
}

foreach ( WeaverNodeSchema node in schema.Nodes ) {
	if ( node.IsAbstract ) { continue; }

	var rels = new List<WeaverRelSchema>();
	string interfaces = "";
	string steps = "";
	
	foreach ( WeaverRelSchema rel in schema.Rels ) {
		if ( rel.FromNode != node && rel.ToNode != node ) { continue; }
		rels.Add(rel);
		bool isOut = (rel.FromNode == node);

		interfaces += (interfaces == "" ? "" : ", ")+PathUtil.GetRelInterface(rel, isOut);

		if ( node.Name != "Root" && rel.FromNode.Name == "Root" ) { continue; }
		steps += (steps == "" ? "" : ", ")+"\"/"+PathUtil.GetRelProp(rel, isOut)+"\"";
	}
	
	string typeIdIsLong = "false";
	
	foreach ( WeaverPropSchema prop in node.Props ) {
		if ( prop.Name != node.Name+"Id" ) { continue; }
		typeIdIsLong = (prop.Type == typeof(long) ? "true" : "false");
		break;
	}
#>
	/*================================================================================================*/
	public partial class <#= node.Name #>Step : NodeStep<<#= "Fab"+node.Name #>>,
			<#= interfaces #> {
	
		private static readonly string[] AvailSteps = new string[] { <#= steps #> };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public <#= node.Name #>Step(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "<#= node.Name #>Id"; } }
		protected override bool TypeIdIsLong { get { return <#= typeIdIsLong #>; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IStep GetNextStep(StepData pData) {
			switch ( pData.Command ) {
<#
	foreach ( WeaverRelSchema rel in rels ) {
		bool isOut = (rel.FromNode == node);
		var propName = PathUtil.GetRelProp(rel, isOut);
#>
				case "<#= propName.ToLower() #>": return <#= propName #>;
<#
	} //end rel loop
#>
			}

			return base.GetNextStep(pData);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
<#
	foreach ( WeaverRelSchema rel in schema.Rels ) {
		if ( rel.FromNode != node && rel.ToNode != node ) { continue; }
		
		bool isOut = (rel.FromNode == node);
		var propType = PathUtil.GetRelPropType(rel, isOut)+"Step";
		var propName = PathUtil.GetRelProp(rel, isOut);
		var isToNode = (isOut ? "true" : "false");
		var script = (isOut ? "outE" : "inE")+"('"+PathUtil.GetRelLabel(rel)+"')";
#>
		/*--------------------------------------------------------------------------------------------*/
		public <#= propType #> <#= propName #> {
			get { return new <#= propType #>(<#= isToNode #>, Path.Add("<#= script #>")); }
		}

<#
	} //end rel loop
#>
	}

<#
}
#>
}