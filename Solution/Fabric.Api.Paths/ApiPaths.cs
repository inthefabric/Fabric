// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on 12/10/2012 9:50:38 PM

using Fabric.Api.Dto;

namespace Fabric.Api.Paths {
	
	/*================================================================================================*/
	public interface IContainsAppList {
		AppStep ContainsAppList { get; }
	}

	/*================================================================================================*/
	public interface IInRootContains {
		RootStep InRootContains { get; }
	}

	/*================================================================================================*/
	public interface IContainsArtifactList {
		ArtifactStep ContainsArtifactList { get; }
	}

	/*================================================================================================*/
	public interface IContainsArtifactTypeList {
		ArtifactTypeStep ContainsArtifactTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsCrowdList {
		CrowdStep ContainsCrowdList { get; }
	}

	/*================================================================================================*/
	public interface IContainsCrowdianList {
		CrowdianStep ContainsCrowdianList { get; }
	}

	/*================================================================================================*/
	public interface IContainsCrowdianTypeList {
		CrowdianTypeStep ContainsCrowdianTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsCrowdianTypeAssignList {
		CrowdianTypeAssignStep ContainsCrowdianTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface IContainsEmailList {
		EmailStep ContainsEmailList { get; }
	}

	/*================================================================================================*/
	public interface IContainsLabelList {
		LabelStep ContainsLabelList { get; }
	}

	/*================================================================================================*/
	public interface IContainsMemberList {
		MemberStep ContainsMemberList { get; }
	}

	/*================================================================================================*/
	public interface IContainsMemberTypeList {
		MemberTypeStep ContainsMemberTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsMemberTypeAssignList {
		MemberTypeAssignStep ContainsMemberTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface IContainsThingList {
		ThingStep ContainsThingList { get; }
	}

	/*================================================================================================*/
	public interface IContainsUrlList {
		UrlStep ContainsUrlList { get; }
	}

	/*================================================================================================*/
	public interface IContainsUserList {
		UserStep ContainsUserList { get; }
	}

	/*================================================================================================*/
	public interface IContainsFactorList {
		FactorStep ContainsFactorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsFactorAssertionList {
		FactorAssertionStep ContainsFactorAssertionList { get; }
	}

	/*================================================================================================*/
	public interface IContainsDescriptorList {
		DescriptorStep ContainsDescriptorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsDescriptorTypeList {
		DescriptorTypeStep ContainsDescriptorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsDirectorList {
		DirectorStep ContainsDirectorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsDirectorTypeList {
		DirectorTypeStep ContainsDirectorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsDirectorActionList {
		DirectorActionStep ContainsDirectorActionList { get; }
	}

	/*================================================================================================*/
	public interface IContainsEventorList {
		EventorStep ContainsEventorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsEventorTypeList {
		EventorTypeStep ContainsEventorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsEventorPrecisionList {
		EventorPrecisionStep ContainsEventorPrecisionList { get; }
	}

	/*================================================================================================*/
	public interface IContainsIdentorList {
		IdentorStep ContainsIdentorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsIdentorTypeList {
		IdentorTypeStep ContainsIdentorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsLocatorList {
		LocatorStep ContainsLocatorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsLocatorTypeList {
		LocatorTypeStep ContainsLocatorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorList {
		VectorStep ContainsVectorList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorTypeList {
		VectorTypeStep ContainsVectorTypeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorRangeList {
		VectorRangeStep ContainsVectorRangeList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorRangeLevelList {
		VectorRangeLevelStep ContainsVectorRangeLevelList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorUnitList {
		VectorUnitStep ContainsVectorUnitList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorUnitPrefixList {
		VectorUnitPrefixStep ContainsVectorUnitPrefixList { get; }
	}

	/*================================================================================================*/
	public interface IContainsVectorUnitDerivedList {
		VectorUnitDerivedStep ContainsVectorUnitDerivedList { get; }
	}

	/*================================================================================================*/
	public interface IContainsOauthAccessList {
		OauthAccessStep ContainsOauthAccessList { get; }
	}

	/*================================================================================================*/
	public interface IContainsOauthDomainList {
		OauthDomainStep ContainsOauthDomainList { get; }
	}

	/*================================================================================================*/
	public interface IContainsOauthGrantList {
		OauthGrantStep ContainsOauthGrantList { get; }
	}

	/*================================================================================================*/
	public interface IContainsOauthScopeList {
		OauthScopeStep ContainsOauthScopeList { get; }
	}

	/*================================================================================================*/
	public interface IHasArtifact {
		ArtifactStep HasArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInAppHas {
		AppStep InAppHas { get; }
	}

	/*================================================================================================*/
	public interface IUsesEmail {
		EmailStep UsesEmail { get; }
	}

	/*================================================================================================*/
	public interface IInAppUses {
		AppStep InAppUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesArtifactType {
		ArtifactTypeStep UsesArtifactType { get; }
	}

	/*================================================================================================*/
	public interface IInArtifactUsesList {
		ArtifactStep InArtifactListUses { get; }
	}

	/*================================================================================================*/
	public interface IInCrowdHas {
		CrowdStep InCrowdHas { get; }
	}

	/*================================================================================================*/
	public interface IUsesCrowd {
		CrowdStep UsesCrowd { get; }
	}

	/*================================================================================================*/
	public interface IInCrowdianUsesList {
		CrowdianStep InCrowdianListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesUser {
		UserStep UsesUser { get; }
	}

	/*================================================================================================*/
	public interface IHasCrowdianTypeAssign {
		CrowdianTypeAssignStep HasCrowdianTypeAssign { get; }
	}

	/*================================================================================================*/
	public interface IInCrowdianHas {
		CrowdianStep InCrowdianHas { get; }
	}

	/*================================================================================================*/
	public interface IHasHistoricCrowdianTypeAssignList {
		CrowdianTypeAssignStep HasHistoricCrowdianTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface IInCrowdianHasHistoric {
		CrowdianStep InCrowdianHasHistoric { get; }
	}

	/*================================================================================================*/
	public interface IUsesCrowdianType {
		CrowdianTypeStep UsesCrowdianType { get; }
	}

	/*================================================================================================*/
	public interface IInCrowdianTypeAssignUsesList {
		CrowdianTypeAssignStep InCrowdianTypeAssignListUses { get; }
	}

	/*================================================================================================*/
	public interface IInLabelHas {
		LabelStep InLabelHas { get; }
	}

	/*================================================================================================*/
	public interface IUsesApp {
		AppStep UsesApp { get; }
	}

	/*================================================================================================*/
	public interface IInMemberUsesList {
		MemberStep InMemberListUses { get; }
	}

	/*================================================================================================*/
	public interface IHasMemberTypeAssign {
		MemberTypeAssignStep HasMemberTypeAssign { get; }
	}

	/*================================================================================================*/
	public interface IInMemberHas {
		MemberStep InMemberHas { get; }
	}

	/*================================================================================================*/
	public interface IHasHistoricMemberTypeAssignList {
		MemberTypeAssignStep HasHistoricMemberTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface IInMemberHasHistoric {
		MemberStep InMemberHasHistoric { get; }
	}

	/*================================================================================================*/
	public interface ICreatesArtifactList {
		ArtifactStep CreatesArtifactList { get; }
	}

	/*================================================================================================*/
	public interface IInMemberCreates {
		MemberStep InMemberCreates { get; }
	}

	/*================================================================================================*/
	public interface ICreatesMemberTypeAssignList {
		MemberTypeAssignStep CreatesMemberTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface ICreatesFactorList {
		FactorStep CreatesFactorList { get; }
	}

	/*================================================================================================*/
	public interface IUsesMemberType {
		MemberTypeStep UsesMemberType { get; }
	}

	/*================================================================================================*/
	public interface IInMemberTypeAssignUsesList {
		MemberTypeAssignStep InMemberTypeAssignListUses { get; }
	}

	/*================================================================================================*/
	public interface IInThingHas {
		ThingStep InThingHas { get; }
	}

	/*================================================================================================*/
	public interface IInUrlHas {
		UrlStep InUrlHas { get; }
	}

	/*================================================================================================*/
	public interface IInUserHas {
		UserStep InUserHas { get; }
	}

	/*================================================================================================*/
	public interface IInUserUses {
		UserStep InUserUses { get; }
	}

	/*================================================================================================*/
	public interface ICreatesCrowdianTypeAssignList {
		CrowdianTypeAssignStep CreatesCrowdianTypeAssignList { get; }
	}

	/*================================================================================================*/
	public interface IInUserCreates {
		UserStep InUserCreates { get; }
	}

	/*================================================================================================*/
	public interface IUsesPrimaryArtifact {
		ArtifactStep UsesPrimaryArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInFactorUsesPrimaryList {
		FactorStep InFactorListUsesPrimary { get; }
	}

	/*================================================================================================*/
	public interface IUsesRelatedArtifact {
		ArtifactStep UsesRelatedArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInFactorUsesRelatedList {
		FactorStep InFactorListUsesRelated { get; }
	}

	/*================================================================================================*/
	public interface IUsesFactorAssertion {
		FactorAssertionStep UsesFactorAssertion { get; }
	}

	/*================================================================================================*/
	public interface IInFactorUsesList {
		FactorStep InFactorListUses { get; }
	}

	/*================================================================================================*/
	public interface IReplacesFactor {
		FactorStep ReplacesFactor { get; }
	}

	/*================================================================================================*/
	public interface IInFactorReplaces {
		FactorStep InFactorReplaces { get; }
	}

	/*================================================================================================*/
	public interface IUsesDescriptor {
		DescriptorStep UsesDescriptor { get; }
	}

	/*================================================================================================*/
	public interface IUsesDirector {
		DirectorStep UsesDirector { get; }
	}

	/*================================================================================================*/
	public interface IUsesEventor {
		EventorStep UsesEventor { get; }
	}

	/*================================================================================================*/
	public interface IUsesIdentor {
		IdentorStep UsesIdentor { get; }
	}

	/*================================================================================================*/
	public interface IUsesLocator {
		LocatorStep UsesLocator { get; }
	}

	/*================================================================================================*/
	public interface IUsesVector {
		VectorStep UsesVector { get; }
	}

	/*================================================================================================*/
	public interface IUsesDescriptorType {
		DescriptorTypeStep UsesDescriptorType { get; }
	}

	/*================================================================================================*/
	public interface IInDescriptorUsesList {
		DescriptorStep InDescriptorListUses { get; }
	}

	/*================================================================================================*/
	public interface IRefinesPrimaryWithArtifact {
		ArtifactStep RefinesPrimaryWithArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInDescriptorRefinesPrimaryWithList {
		DescriptorStep InDescriptorListRefinesPrimaryWith { get; }
	}

	/*================================================================================================*/
	public interface IRefinesRelatedWithArtifact {
		ArtifactStep RefinesRelatedWithArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInDescriptorRefinesRelatedWithList {
		DescriptorStep InDescriptorListRefinesRelatedWith { get; }
	}

	/*================================================================================================*/
	public interface IRefinesTypeWithArtifact {
		ArtifactStep RefinesTypeWithArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInDescriptorRefinesTypeWithList {
		DescriptorStep InDescriptorListRefinesTypeWith { get; }
	}

	/*================================================================================================*/
	public interface IUsesDirectorType {
		DirectorTypeStep UsesDirectorType { get; }
	}

	/*================================================================================================*/
	public interface IInDirectorUsesList {
		DirectorStep InDirectorListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesPrimaryDirectorAction {
		DirectorActionStep UsesPrimaryDirectorAction { get; }
	}

	/*================================================================================================*/
	public interface IInDirectorUsesPrimaryList {
		DirectorStep InDirectorListUsesPrimary { get; }
	}

	/*================================================================================================*/
	public interface IUsesRelatedDirectorAction {
		DirectorActionStep UsesRelatedDirectorAction { get; }
	}

	/*================================================================================================*/
	public interface IInDirectorUsesRelatedList {
		DirectorStep InDirectorListUsesRelated { get; }
	}

	/*================================================================================================*/
	public interface IUsesEventorType {
		EventorTypeStep UsesEventorType { get; }
	}

	/*================================================================================================*/
	public interface IInEventorUsesList {
		EventorStep InEventorListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesEventorPrecision {
		EventorPrecisionStep UsesEventorPrecision { get; }
	}

	/*================================================================================================*/
	public interface IUsesIdentorType {
		IdentorTypeStep UsesIdentorType { get; }
	}

	/*================================================================================================*/
	public interface IInIdentorUsesList {
		IdentorStep InIdentorListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesLocatorType {
		LocatorTypeStep UsesLocatorType { get; }
	}

	/*================================================================================================*/
	public interface IInLocatorUsesList {
		LocatorStep InLocatorListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesAxisArtifact {
		ArtifactStep UsesAxisArtifact { get; }
	}

	/*================================================================================================*/
	public interface IInVectorUsesAxisList {
		VectorStep InVectorListUsesAxis { get; }
	}

	/*================================================================================================*/
	public interface IUsesVectorType {
		VectorTypeStep UsesVectorType { get; }
	}

	/*================================================================================================*/
	public interface IInVectorUsesList {
		VectorStep InVectorListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesVectorUnit {
		VectorUnitStep UsesVectorUnit { get; }
	}

	/*================================================================================================*/
	public interface IUsesVectorUnitPrefix {
		VectorUnitPrefixStep UsesVectorUnitPrefix { get; }
	}

	/*================================================================================================*/
	public interface IUsesVectorRange {
		VectorRangeStep UsesVectorRange { get; }
	}

	/*================================================================================================*/
	public interface IInVectorTypeUsesList {
		VectorTypeStep InVectorTypeListUses { get; }
	}

	/*================================================================================================*/
	public interface IUsesVectorRangeLevelList {
		VectorRangeLevelStep UsesVectorRangeLevelList { get; }
	}

	/*================================================================================================*/
	public interface IInVectorRangeUsesList {
		VectorRangeStep InVectorRangeListUses { get; }
	}

	/*================================================================================================*/
	public interface IDefinesVectorUnit {
		VectorUnitStep DefinesVectorUnit { get; }
	}

	/*================================================================================================*/
	public interface IInVectorUnitDerivedDefinesList {
		VectorUnitDerivedStep InVectorUnitDerivedListDefines { get; }
	}

	/*================================================================================================*/
	public interface IRaisesToExpVectorUnit {
		VectorUnitStep RaisesToExpVectorUnit { get; }
	}

	/*================================================================================================*/
	public interface IInVectorUnitDerivedRaisesToExpList {
		VectorUnitDerivedStep InVectorUnitDerivedListRaisesToExp { get; }
	}

	/*================================================================================================*/
	public interface IInVectorUnitDerivedUsesList {
		VectorUnitDerivedStep InVectorUnitDerivedListUses { get; }
	}

	/*================================================================================================*/
	public interface IInOauthAccessUsesList {
		OauthAccessStep InOauthAccessListUses { get; }
	}

	/*================================================================================================*/
	public interface IInOauthDomainUsesList {
		OauthDomainStep InOauthDomainListUses { get; }
	}

	/*================================================================================================*/
	public interface IInOauthGrantUsesList {
		OauthGrantStep InOauthGrantListUses { get; }
	}

	/*================================================================================================*/
	public interface IInOauthScopeUsesList {
		OauthScopeStep InOauthScopeListUses { get; }
	}

	/*================================================================================================*/
	public partial class RootStep : PathDomainStep<FabRoot>,
			IContainsAppList, IContainsArtifactList, IContainsArtifactTypeList, IContainsCrowdList, IContainsCrowdianList, IContainsCrowdianTypeList, IContainsCrowdianTypeAssignList, IContainsEmailList, IContainsLabelList, IContainsMemberList, IContainsMemberTypeList, IContainsMemberTypeAssignList, IContainsThingList, IContainsUrlList, IContainsUserList, IContainsFactorList, IContainsFactorAssertionList, IContainsDescriptorList, IContainsDescriptorTypeList, IContainsDirectorList, IContainsDirectorTypeList, IContainsDirectorActionList, IContainsEventorList, IContainsEventorTypeList, IContainsEventorPrecisionList, IContainsIdentorList, IContainsIdentorTypeList, IContainsLocatorList, IContainsLocatorTypeList, IContainsVectorList, IContainsVectorTypeList, IContainsVectorRangeList, IContainsVectorRangeLevelList, IContainsVectorUnitList, IContainsVectorUnitPrefixList, IContainsVectorUnitDerivedList, IContainsOauthAccessList, IContainsOauthDomainList, IContainsOauthGrantList, IContainsOauthScopeList {
	
		private static readonly string[] AvailSteps = new string[] { "/ContainsAppList", "/ContainsArtifactList", "/ContainsArtifactTypeList", "/ContainsCrowdList", "/ContainsCrowdianList", "/ContainsCrowdianTypeList", "/ContainsCrowdianTypeAssignList", "/ContainsEmailList", "/ContainsLabelList", "/ContainsMemberList", "/ContainsMemberTypeList", "/ContainsMemberTypeAssignList", "/ContainsThingList", "/ContainsUrlList", "/ContainsUserList", "/ContainsFactorList", "/ContainsFactorAssertionList", "/ContainsDescriptorList", "/ContainsDescriptorTypeList", "/ContainsDirectorList", "/ContainsDirectorTypeList", "/ContainsDirectorActionList", "/ContainsEventorList", "/ContainsEventorTypeList", "/ContainsEventorPrecisionList", "/ContainsIdentorList", "/ContainsIdentorTypeList", "/ContainsLocatorList", "/ContainsLocatorTypeList", "/ContainsVectorList", "/ContainsVectorTypeList", "/ContainsVectorRangeList", "/ContainsVectorRangeLevelList", "/ContainsVectorUnitList", "/ContainsVectorUnitPrefixList", "/ContainsVectorUnitDerivedList", "/ContainsOauthAccessList", "/ContainsOauthDomainList", "/ContainsOauthGrantList", "/ContainsOauthScopeList" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "RootId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "containsapplist": return ContainsAppList;
				case "containsartifactlist": return ContainsArtifactList;
				case "containsartifacttypelist": return ContainsArtifactTypeList;
				case "containscrowdlist": return ContainsCrowdList;
				case "containscrowdianlist": return ContainsCrowdianList;
				case "containscrowdiantypelist": return ContainsCrowdianTypeList;
				case "containscrowdiantypeassignlist": return ContainsCrowdianTypeAssignList;
				case "containsemaillist": return ContainsEmailList;
				case "containslabellist": return ContainsLabelList;
				case "containsmemberlist": return ContainsMemberList;
				case "containsmembertypelist": return ContainsMemberTypeList;
				case "containsmembertypeassignlist": return ContainsMemberTypeAssignList;
				case "containsthinglist": return ContainsThingList;
				case "containsurllist": return ContainsUrlList;
				case "containsuserlist": return ContainsUserList;
				case "containsfactorlist": return ContainsFactorList;
				case "containsfactorassertionlist": return ContainsFactorAssertionList;
				case "containsdescriptorlist": return ContainsDescriptorList;
				case "containsdescriptortypelist": return ContainsDescriptorTypeList;
				case "containsdirectorlist": return ContainsDirectorList;
				case "containsdirectortypelist": return ContainsDirectorTypeList;
				case "containsdirectoractionlist": return ContainsDirectorActionList;
				case "containseventorlist": return ContainsEventorList;
				case "containseventortypelist": return ContainsEventorTypeList;
				case "containseventorprecisionlist": return ContainsEventorPrecisionList;
				case "containsidentorlist": return ContainsIdentorList;
				case "containsidentortypelist": return ContainsIdentorTypeList;
				case "containslocatorlist": return ContainsLocatorList;
				case "containslocatortypelist": return ContainsLocatorTypeList;
				case "containsvectorlist": return ContainsVectorList;
				case "containsvectortypelist": return ContainsVectorTypeList;
				case "containsvectorrangelist": return ContainsVectorRangeList;
				case "containsvectorrangelevellist": return ContainsVectorRangeLevelList;
				case "containsvectorunitlist": return ContainsVectorUnitList;
				case "containsvectorunitprefixlist": return ContainsVectorUnitPrefixList;
				case "containsvectorunitderivedlist": return ContainsVectorUnitDerivedList;
				case "containsoauthaccesslist": return ContainsOauthAccessList;
				case "containsoauthdomainlist": return ContainsOauthDomainList;
				case "containsoauthgrantlist": return ContainsOauthGrantList;
				case "containsoauthscopelist": return ContainsOauthScopeList;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public AppStep ContainsAppList {
			get { return new AppStep(true, Path.Add("outE('RootContainsApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep ContainsArtifactList {
			get { return new ArtifactStep(true, Path.Add("outE('RootContainsArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactTypeStep ContainsArtifactTypeList {
			get { return new ArtifactTypeStep(true, Path.Add("outE('RootContainsArtifactType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdStep ContainsCrowdList {
			get { return new CrowdStep(true, Path.Add("outE('RootContainsCrowd')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep ContainsCrowdianList {
			get { return new CrowdianStep(true, Path.Add("outE('RootContainsCrowdian')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeStep ContainsCrowdianTypeList {
			get { return new CrowdianTypeStep(true, Path.Add("outE('RootContainsCrowdianType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep ContainsCrowdianTypeAssignList {
			get { return new CrowdianTypeAssignStep(true, Path.Add("outE('RootContainsCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EmailStep ContainsEmailList {
			get { return new EmailStep(true, Path.Add("outE('RootContainsEmail')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LabelStep ContainsLabelList {
			get { return new LabelStep(true, Path.Add("outE('RootContainsLabel')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep ContainsMemberList {
			get { return new MemberStep(true, Path.Add("outE('RootContainsMember')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeStep ContainsMemberTypeList {
			get { return new MemberTypeStep(true, Path.Add("outE('RootContainsMemberType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep ContainsMemberTypeAssignList {
			get { return new MemberTypeAssignStep(true, Path.Add("outE('RootContainsMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ThingStep ContainsThingList {
			get { return new ThingStep(true, Path.Add("outE('RootContainsThing')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UrlStep ContainsUrlList {
			get { return new UrlStep(true, Path.Add("outE('RootContainsUrl')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep ContainsUserList {
			get { return new UserStep(true, Path.Add("outE('RootContainsUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep ContainsFactorList {
			get { return new FactorStep(true, Path.Add("outE('RootContainsFactor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorAssertionStep ContainsFactorAssertionList {
			get { return new FactorAssertionStep(true, Path.Add("outE('RootContainsFactorAssertion')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep ContainsDescriptorList {
			get { return new DescriptorStep(true, Path.Add("outE('RootContainsDescriptor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorTypeStep ContainsDescriptorTypeList {
			get { return new DescriptorTypeStep(true, Path.Add("outE('RootContainsDescriptorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep ContainsDirectorList {
			get { return new DirectorStep(true, Path.Add("outE('RootContainsDirector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorTypeStep ContainsDirectorTypeList {
			get { return new DirectorTypeStep(true, Path.Add("outE('RootContainsDirectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorActionStep ContainsDirectorActionList {
			get { return new DirectorActionStep(true, Path.Add("outE('RootContainsDirectorAction')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorStep ContainsEventorList {
			get { return new EventorStep(true, Path.Add("outE('RootContainsEventor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorTypeStep ContainsEventorTypeList {
			get { return new EventorTypeStep(true, Path.Add("outE('RootContainsEventorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorPrecisionStep ContainsEventorPrecisionList {
			get { return new EventorPrecisionStep(true, Path.Add("outE('RootContainsEventorPrecision')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public IdentorStep ContainsIdentorList {
			get { return new IdentorStep(true, Path.Add("outE('RootContainsIdentor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public IdentorTypeStep ContainsIdentorTypeList {
			get { return new IdentorTypeStep(true, Path.Add("outE('RootContainsIdentorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LocatorStep ContainsLocatorList {
			get { return new LocatorStep(true, Path.Add("outE('RootContainsLocator')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LocatorTypeStep ContainsLocatorTypeList {
			get { return new LocatorTypeStep(true, Path.Add("outE('RootContainsLocatorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep ContainsVectorList {
			get { return new VectorStep(true, Path.Add("outE('RootContainsVector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorTypeStep ContainsVectorTypeList {
			get { return new VectorTypeStep(true, Path.Add("outE('RootContainsVectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeStep ContainsVectorRangeList {
			get { return new VectorRangeStep(true, Path.Add("outE('RootContainsVectorRange')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeLevelStep ContainsVectorRangeLevelList {
			get { return new VectorRangeLevelStep(true, Path.Add("outE('RootContainsVectorRangeLevel')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitStep ContainsVectorUnitList {
			get { return new VectorUnitStep(true, Path.Add("outE('RootContainsVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitPrefixStep ContainsVectorUnitPrefixList {
			get { return new VectorUnitPrefixStep(true, Path.Add("outE('RootContainsVectorUnitPrefix')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitDerivedStep ContainsVectorUnitDerivedList {
			get { return new VectorUnitDerivedStep(true, Path.Add("outE('RootContainsVectorUnitDerived')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthAccessStep ContainsOauthAccessList {
			get { return new OauthAccessStep(true, Path.Add("outE('RootContainsOauthAccess')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthDomainStep ContainsOauthDomainList {
			get { return new OauthDomainStep(true, Path.Add("outE('RootContainsOauthDomain')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthGrantStep ContainsOauthGrantList {
			get { return new OauthGrantStep(true, Path.Add("outE('RootContainsOauthGrant')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthScopeStep ContainsOauthScopeList {
			get { return new OauthScopeStep(true, Path.Add("outE('RootContainsOauthScope')")); }
		}

	}

	/*================================================================================================*/
	public partial class AppStep : PathDomainStep<FabApp>,
			IInRootContains, IHasArtifact, IUsesEmail, IInMemberUsesList, IInOauthAccessUsesList, IInOauthDomainUsesList, IInOauthGrantUsesList, IInOauthScopeUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/HasArtifact", "/UsesEmail", "/InMemberListUses", "/InOauthAccessListUses", "/InOauthDomainListUses", "/InOauthGrantListUses", "/InOauthScopeListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public AppStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "AppId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "hasartifact": return HasArtifact;
				case "usesemail": return UsesEmail;
				case "inmemberlistuses": return InMemberListUses;
				case "inoauthaccesslistuses": return InOauthAccessListUses;
				case "inoauthdomainlistuses": return InOauthDomainListUses;
				case "inoauthgrantlistuses": return InOauthGrantListUses;
				case "inoauthscopelistuses": return InOauthScopeListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('AppHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EmailStep UsesEmail {
			get { return new EmailStep(true, Path.Add("outE('AppUsesEmail')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberListUses {
			get { return new MemberStep(false, Path.Add("inE('MemberUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthAccessStep InOauthAccessListUses {
			get { return new OauthAccessStep(false, Path.Add("inE('OauthAccessUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthDomainStep InOauthDomainListUses {
			get { return new OauthDomainStep(false, Path.Add("inE('OauthDomainUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthGrantStep InOauthGrantListUses {
			get { return new OauthGrantStep(false, Path.Add("inE('OauthGrantUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthScopeStep InOauthScopeListUses {
			get { return new OauthScopeStep(false, Path.Add("inE('OauthScopeUsesApp')")); }
		}

	}

	/*================================================================================================*/
	public partial class ArtifactStep : PathDomainStep<FabArtifact>,
			IInRootContains, IInAppHas, IUsesArtifactType, IInCrowdHas, IInLabelHas, IInMemberCreates, IInThingHas, IInUrlHas, IInUserHas, IInFactorUsesPrimaryList, IInFactorUsesRelatedList, IInDescriptorRefinesPrimaryWithList, IInDescriptorRefinesRelatedWithList, IInDescriptorRefinesTypeWithList, IInVectorUsesAxisList {
	
		private static readonly string[] AvailSteps = new string[] { "/InAppHas", "/UsesArtifactType", "/InCrowdHas", "/InLabelHas", "/InMemberCreates", "/InThingHas", "/InUrlHas", "/InUserHas", "/InFactorListUsesPrimary", "/InFactorListUsesRelated", "/InDescriptorListRefinesPrimaryWith", "/InDescriptorListRefinesRelatedWith", "/InDescriptorListRefinesTypeWith", "/InVectorListUsesAxis" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "ArtifactId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inapphas": return InAppHas;
				case "usesartifacttype": return UsesArtifactType;
				case "incrowdhas": return InCrowdHas;
				case "inlabelhas": return InLabelHas;
				case "inmembercreates": return InMemberCreates;
				case "inthinghas": return InThingHas;
				case "inurlhas": return InUrlHas;
				case "inuserhas": return InUserHas;
				case "infactorlistusesprimary": return InFactorListUsesPrimary;
				case "infactorlistusesrelated": return InFactorListUsesRelated;
				case "indescriptorlistrefinesprimarywith": return InDescriptorListRefinesPrimaryWith;
				case "indescriptorlistrefinesrelatedwith": return InDescriptorListRefinesRelatedWith;
				case "indescriptorlistrefinestypewith": return InDescriptorListRefinesTypeWith;
				case "invectorlistusesaxis": return InVectorListUsesAxis;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep InAppHas {
			get { return new AppStep(false, Path.Add("inE('AppHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactTypeStep UsesArtifactType {
			get { return new ArtifactTypeStep(true, Path.Add("outE('ArtifactUsesArtifactType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdStep InCrowdHas {
			get { return new CrowdStep(false, Path.Add("inE('CrowdHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LabelStep InLabelHas {
			get { return new LabelStep(false, Path.Add("inE('LabelHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberCreates {
			get { return new MemberStep(false, Path.Add("inE('MemberCreatesArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ThingStep InThingHas {
			get { return new ThingStep(false, Path.Add("inE('ThingHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UrlStep InUrlHas {
			get { return new UrlStep(false, Path.Add("inE('UrlHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep InUserHas {
			get { return new UserStep(false, Path.Add("inE('UserHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUsesPrimary {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesPrimaryArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUsesRelated {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesRelatedArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep InDescriptorListRefinesPrimaryWith {
			get { return new DescriptorStep(false, Path.Add("inE('DescriptorRefinesPrimaryWithArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep InDescriptorListRefinesRelatedWith {
			get { return new DescriptorStep(false, Path.Add("inE('DescriptorRefinesRelatedWithArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep InDescriptorListRefinesTypeWith {
			get { return new DescriptorStep(false, Path.Add("inE('DescriptorRefinesTypeWithArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep InVectorListUsesAxis {
			get { return new VectorStep(false, Path.Add("inE('VectorUsesAxisArtifact')")); }
		}

	}

	/*================================================================================================*/
	public partial class ArtifactTypeStep : PathDomainStep<FabArtifactType>,
			IInRootContains, IInArtifactUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InArtifactListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public ArtifactTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "ArtifactTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inartifactlistuses": return InArtifactListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsArtifactType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep InArtifactListUses {
			get { return new ArtifactStep(false, Path.Add("inE('ArtifactUsesArtifactType')")); }
		}

	}

	/*================================================================================================*/
	public partial class CrowdStep : PathDomainStep<FabCrowd>,
			IInRootContains, IHasArtifact, IInCrowdianUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/HasArtifact", "/InCrowdianListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public CrowdStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "CrowdId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "hasartifact": return HasArtifact;
				case "incrowdianlistuses": return InCrowdianListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsCrowd')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('CrowdHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep InCrowdianListUses {
			get { return new CrowdianStep(false, Path.Add("inE('CrowdianUsesCrowd')")); }
		}

	}

	/*================================================================================================*/
	public partial class CrowdianStep : PathDomainStep<FabCrowdian>,
			IInRootContains, IUsesCrowd, IUsesUser, IHasCrowdianTypeAssign, IHasHistoricCrowdianTypeAssignList {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesCrowd", "/UsesUser", "/HasCrowdianTypeAssign", "/HasHistoricCrowdianTypeAssignList" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "CrowdianId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usescrowd": return UsesCrowd;
				case "usesuser": return UsesUser;
				case "hascrowdiantypeassign": return HasCrowdianTypeAssign;
				case "hashistoriccrowdiantypeassignlist": return HasHistoricCrowdianTypeAssignList;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsCrowdian')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdStep UsesCrowd {
			get { return new CrowdStep(true, Path.Add("outE('CrowdianUsesCrowd')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep UsesUser {
			get { return new UserStep(true, Path.Add("outE('CrowdianUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep HasCrowdianTypeAssign {
			get { return new CrowdianTypeAssignStep(true, Path.Add("outE('CrowdianHasCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep HasHistoricCrowdianTypeAssignList {
			get { return new CrowdianTypeAssignStep(true, Path.Add("outE('CrowdianHasHistoricCrowdianTypeAssign')")); }
		}

	}

	/*================================================================================================*/
	public partial class CrowdianTypeStep : PathDomainStep<FabCrowdianType>,
			IInRootContains, IInCrowdianTypeAssignUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InCrowdianTypeAssignListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "CrowdianTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "incrowdiantypeassignlistuses": return InCrowdianTypeAssignListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsCrowdianType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep InCrowdianTypeAssignListUses {
			get { return new CrowdianTypeAssignStep(false, Path.Add("inE('CrowdianTypeAssignUsesCrowdianType')")); }
		}

	}

	/*================================================================================================*/
	public partial class CrowdianTypeAssignStep : PathDomainStep<FabCrowdianTypeAssign>,
			IInRootContains, IInCrowdianHas, IInCrowdianHasHistoric, IUsesCrowdianType, IInUserCreates {
	
		private static readonly string[] AvailSteps = new string[] { "/InCrowdianHas", "/InCrowdianHasHistoric", "/UsesCrowdianType", "/InUserCreates" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "CrowdianTypeAssignId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "incrowdianhas": return InCrowdianHas;
				case "incrowdianhashistoric": return InCrowdianHasHistoric;
				case "usescrowdiantype": return UsesCrowdianType;
				case "inusercreates": return InUserCreates;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep InCrowdianHas {
			get { return new CrowdianStep(false, Path.Add("inE('CrowdianHasCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep InCrowdianHasHistoric {
			get { return new CrowdianStep(false, Path.Add("inE('CrowdianHasHistoricCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeStep UsesCrowdianType {
			get { return new CrowdianTypeStep(true, Path.Add("outE('CrowdianTypeAssignUsesCrowdianType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep InUserCreates {
			get { return new UserStep(false, Path.Add("inE('UserCreatesCrowdianTypeAssign')")); }
		}

	}

	/*================================================================================================*/
	public partial class EmailStep : PathDomainStep<FabEmail>,
			IInRootContains, IInAppUses, IInUserUses {
	
		private static readonly string[] AvailSteps = new string[] { "/InAppUses", "/InUserUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public EmailStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "EmailId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inappuses": return InAppUses;
				case "inuseruses": return InUserUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsEmail')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep InAppUses {
			get { return new AppStep(false, Path.Add("inE('AppUsesEmail')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep InUserUses {
			get { return new UserStep(false, Path.Add("inE('UserUsesEmail')")); }
		}

	}

	/*================================================================================================*/
	public partial class LabelStep : PathDomainStep<FabLabel>,
			IInRootContains, IHasArtifact {
	
		private static readonly string[] AvailSteps = new string[] { "/HasArtifact" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public LabelStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "LabelId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "hasartifact": return HasArtifact;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsLabel')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('LabelHasArtifact')")); }
		}

	}

	/*================================================================================================*/
	public partial class MemberStep : PathDomainStep<FabMember>,
			IInRootContains, IUsesApp, IUsesUser, IHasMemberTypeAssign, IHasHistoricMemberTypeAssignList, ICreatesArtifactList, ICreatesMemberTypeAssignList, ICreatesFactorList {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesApp", "/UsesUser", "/HasMemberTypeAssign", "/HasHistoricMemberTypeAssignList", "/CreatesArtifactList", "/CreatesMemberTypeAssignList", "/CreatesFactorList" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public MemberStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "MemberId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usesapp": return UsesApp;
				case "usesuser": return UsesUser;
				case "hasmembertypeassign": return HasMemberTypeAssign;
				case "hashistoricmembertypeassignlist": return HasHistoricMemberTypeAssignList;
				case "createsartifactlist": return CreatesArtifactList;
				case "createsmembertypeassignlist": return CreatesMemberTypeAssignList;
				case "createsfactorlist": return CreatesFactorList;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsMember')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep UsesApp {
			get { return new AppStep(true, Path.Add("outE('MemberUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep UsesUser {
			get { return new UserStep(true, Path.Add("outE('MemberUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep HasMemberTypeAssign {
			get { return new MemberTypeAssignStep(true, Path.Add("outE('MemberHasMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep HasHistoricMemberTypeAssignList {
			get { return new MemberTypeAssignStep(true, Path.Add("outE('MemberHasHistoricMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep CreatesArtifactList {
			get { return new ArtifactStep(true, Path.Add("outE('MemberCreatesArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep CreatesMemberTypeAssignList {
			get { return new MemberTypeAssignStep(true, Path.Add("outE('MemberCreatesMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep CreatesFactorList {
			get { return new FactorStep(true, Path.Add("outE('MemberCreatesFactor')")); }
		}

	}

	/*================================================================================================*/
	public partial class MemberTypeStep : PathDomainStep<FabMemberType>,
			IInRootContains, IInMemberTypeAssignUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InMemberTypeAssignListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "MemberTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inmembertypeassignlistuses": return InMemberTypeAssignListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsMemberType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep InMemberTypeAssignListUses {
			get { return new MemberTypeAssignStep(false, Path.Add("inE('MemberTypeAssignUsesMemberType')")); }
		}

	}

	/*================================================================================================*/
	public partial class MemberTypeAssignStep : PathDomainStep<FabMemberTypeAssign>,
			IInRootContains, IInMemberHas, IInMemberHasHistoric, IInMemberCreates, IUsesMemberType {
	
		private static readonly string[] AvailSteps = new string[] { "/InMemberHas", "/InMemberHasHistoric", "/InMemberCreates", "/UsesMemberType" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeAssignStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "MemberTypeAssignId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inmemberhas": return InMemberHas;
				case "inmemberhashistoric": return InMemberHasHistoric;
				case "inmembercreates": return InMemberCreates;
				case "usesmembertype": return UsesMemberType;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberHas {
			get { return new MemberStep(false, Path.Add("inE('MemberHasMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberHasHistoric {
			get { return new MemberStep(false, Path.Add("inE('MemberHasHistoricMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberCreates {
			get { return new MemberStep(false, Path.Add("inE('MemberCreatesMemberTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberTypeStep UsesMemberType {
			get { return new MemberTypeStep(true, Path.Add("outE('MemberTypeAssignUsesMemberType')")); }
		}

	}

	/*================================================================================================*/
	public partial class ThingStep : PathDomainStep<FabThing>,
			IInRootContains, IHasArtifact {
	
		private static readonly string[] AvailSteps = new string[] { "/HasArtifact" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public ThingStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "ThingId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "hasartifact": return HasArtifact;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsThing')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('ThingHasArtifact')")); }
		}

	}

	/*================================================================================================*/
	public partial class UrlStep : PathDomainStep<FabUrl>,
			IInRootContains, IHasArtifact {
	
		private static readonly string[] AvailSteps = new string[] { "/HasArtifact" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public UrlStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "UrlId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "hasartifact": return HasArtifact;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsUrl')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('UrlHasArtifact')")); }
		}

	}

	/*================================================================================================*/
	public partial class UserStep : PathDomainStep<FabUser>,
			IInRootContains, IInCrowdianUsesList, IInMemberUsesList, IHasArtifact, IUsesEmail, ICreatesCrowdianTypeAssignList, IInOauthAccessUsesList, IInOauthGrantUsesList, IInOauthScopeUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InCrowdianListUses", "/InMemberListUses", "/HasArtifact", "/UsesEmail", "/CreatesCrowdianTypeAssignList", "/InOauthAccessListUses", "/InOauthGrantListUses", "/InOauthScopeListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public UserStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "UserId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "incrowdianlistuses": return InCrowdianListUses;
				case "inmemberlistuses": return InMemberListUses;
				case "hasartifact": return HasArtifact;
				case "usesemail": return UsesEmail;
				case "createscrowdiantypeassignlist": return CreatesCrowdianTypeAssignList;
				case "inoauthaccesslistuses": return InOauthAccessListUses;
				case "inoauthgrantlistuses": return InOauthGrantListUses;
				case "inoauthscopelistuses": return InOauthScopeListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianStep InCrowdianListUses {
			get { return new CrowdianStep(false, Path.Add("inE('CrowdianUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberListUses {
			get { return new MemberStep(false, Path.Add("inE('MemberUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep HasArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('UserHasArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EmailStep UsesEmail {
			get { return new EmailStep(true, Path.Add("outE('UserUsesEmail')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public CrowdianTypeAssignStep CreatesCrowdianTypeAssignList {
			get { return new CrowdianTypeAssignStep(true, Path.Add("outE('UserCreatesCrowdianTypeAssign')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthAccessStep InOauthAccessListUses {
			get { return new OauthAccessStep(false, Path.Add("inE('OauthAccessUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthGrantStep InOauthGrantListUses {
			get { return new OauthGrantStep(false, Path.Add("inE('OauthGrantUsesUser')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public OauthScopeStep InOauthScopeListUses {
			get { return new OauthScopeStep(false, Path.Add("inE('OauthScopeUsesUser')")); }
		}

	}

	/*================================================================================================*/
	public partial class FactorStep : PathDomainStep<FabFactor>,
			IInRootContains, IInMemberCreates, IUsesPrimaryArtifact, IUsesRelatedArtifact, IUsesFactorAssertion, IReplacesFactor, IUsesDescriptor, IUsesDirector, IUsesEventor, IUsesIdentor, IUsesLocator, IUsesVector {
	
		private static readonly string[] AvailSteps = new string[] { "/InMemberCreates", "/UsesPrimaryArtifact", "/UsesRelatedArtifact", "/UsesFactorAssertion", "/ReplacesFactor", "/UsesDescriptor", "/UsesDirector", "/UsesEventor", "/UsesIdentor", "/UsesLocator", "/UsesVector" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public FactorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "FactorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inmembercreates": return InMemberCreates;
				case "usesprimaryartifact": return UsesPrimaryArtifact;
				case "usesrelatedartifact": return UsesRelatedArtifact;
				case "usesfactorassertion": return UsesFactorAssertion;
				case "replacesfactor": return ReplacesFactor;
				case "usesdescriptor": return UsesDescriptor;
				case "usesdirector": return UsesDirector;
				case "useseventor": return UsesEventor;
				case "usesidentor": return UsesIdentor;
				case "useslocator": return UsesLocator;
				case "usesvector": return UsesVector;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsFactor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public MemberStep InMemberCreates {
			get { return new MemberStep(false, Path.Add("inE('MemberCreatesFactor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep UsesPrimaryArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('FactorUsesPrimaryArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep UsesRelatedArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('FactorUsesRelatedArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorAssertionStep UsesFactorAssertion {
			get { return new FactorAssertionStep(true, Path.Add("outE('FactorUsesFactorAssertion')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep ReplacesFactor {
			get { return new FactorStep(true, Path.Add("outE('FactorReplacesFactor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep UsesDescriptor {
			get { return new DescriptorStep(true, Path.Add("outE('FactorUsesDescriptor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep UsesDirector {
			get { return new DirectorStep(true, Path.Add("outE('FactorUsesDirector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorStep UsesEventor {
			get { return new EventorStep(true, Path.Add("outE('FactorUsesEventor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public IdentorStep UsesIdentor {
			get { return new IdentorStep(true, Path.Add("outE('FactorUsesIdentor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LocatorStep UsesLocator {
			get { return new LocatorStep(true, Path.Add("outE('FactorUsesLocator')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep UsesVector {
			get { return new VectorStep(true, Path.Add("outE('FactorUsesVector')")); }
		}

	}

	/*================================================================================================*/
	public partial class FactorAssertionStep : PathDomainStep<FabFactorAssertion>,
			IInRootContains, IInFactorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public FactorAssertionStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "FactorAssertionId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsFactorAssertion')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesFactorAssertion')")); }
		}

	}

	/*================================================================================================*/
	public partial class DescriptorStep : PathDomainStep<FabDescriptor>,
			IInRootContains, IInFactorUsesList, IUsesDescriptorType, IRefinesPrimaryWithArtifact, IRefinesRelatedWithArtifact, IRefinesTypeWithArtifact {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesDescriptorType", "/RefinesPrimaryWithArtifact", "/RefinesRelatedWithArtifact", "/RefinesTypeWithArtifact" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "DescriptorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "usesdescriptortype": return UsesDescriptorType;
				case "refinesprimarywithartifact": return RefinesPrimaryWithArtifact;
				case "refinesrelatedwithartifact": return RefinesRelatedWithArtifact;
				case "refinestypewithartifact": return RefinesTypeWithArtifact;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsDescriptor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesDescriptor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorTypeStep UsesDescriptorType {
			get { return new DescriptorTypeStep(true, Path.Add("outE('DescriptorUsesDescriptorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep RefinesPrimaryWithArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('DescriptorRefinesPrimaryWithArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep RefinesRelatedWithArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('DescriptorRefinesRelatedWithArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep RefinesTypeWithArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('DescriptorRefinesTypeWithArtifact')")); }
		}

	}

	/*================================================================================================*/
	public partial class DescriptorTypeStep : PathDomainStep<FabDescriptorType>,
			IInRootContains, IInDescriptorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InDescriptorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public DescriptorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "DescriptorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "indescriptorlistuses": return InDescriptorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsDescriptorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DescriptorStep InDescriptorListUses {
			get { return new DescriptorStep(false, Path.Add("inE('DescriptorUsesDescriptorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class DirectorStep : PathDomainStep<FabDirector>,
			IInRootContains, IInFactorUsesList, IUsesDirectorType, IUsesPrimaryDirectorAction, IUsesRelatedDirectorAction {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesDirectorType", "/UsesPrimaryDirectorAction", "/UsesRelatedDirectorAction" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "DirectorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "usesdirectortype": return UsesDirectorType;
				case "usesprimarydirectoraction": return UsesPrimaryDirectorAction;
				case "usesrelateddirectoraction": return UsesRelatedDirectorAction;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsDirector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesDirector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorTypeStep UsesDirectorType {
			get { return new DirectorTypeStep(true, Path.Add("outE('DirectorUsesDirectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorActionStep UsesPrimaryDirectorAction {
			get { return new DirectorActionStep(true, Path.Add("outE('DirectorUsesPrimaryDirectorAction')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorActionStep UsesRelatedDirectorAction {
			get { return new DirectorActionStep(true, Path.Add("outE('DirectorUsesRelatedDirectorAction')")); }
		}

	}

	/*================================================================================================*/
	public partial class DirectorTypeStep : PathDomainStep<FabDirectorType>,
			IInRootContains, IInDirectorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InDirectorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public DirectorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "DirectorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "indirectorlistuses": return InDirectorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsDirectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep InDirectorListUses {
			get { return new DirectorStep(false, Path.Add("inE('DirectorUsesDirectorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class DirectorActionStep : PathDomainStep<FabDirectorAction>,
			IInRootContains, IInDirectorUsesPrimaryList, IInDirectorUsesRelatedList {
	
		private static readonly string[] AvailSteps = new string[] { "/InDirectorListUsesPrimary", "/InDirectorListUsesRelated" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public DirectorActionStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "DirectorActionId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "indirectorlistusesprimary": return InDirectorListUsesPrimary;
				case "indirectorlistusesrelated": return InDirectorListUsesRelated;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsDirectorAction')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep InDirectorListUsesPrimary {
			get { return new DirectorStep(false, Path.Add("inE('DirectorUsesPrimaryDirectorAction')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public DirectorStep InDirectorListUsesRelated {
			get { return new DirectorStep(false, Path.Add("inE('DirectorUsesRelatedDirectorAction')")); }
		}

	}

	/*================================================================================================*/
	public partial class EventorStep : PathDomainStep<FabEventor>,
			IInRootContains, IInFactorUsesList, IUsesEventorType, IUsesEventorPrecision {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesEventorType", "/UsesEventorPrecision" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public EventorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "EventorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "useseventortype": return UsesEventorType;
				case "useseventorprecision": return UsesEventorPrecision;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsEventor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesEventor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorTypeStep UsesEventorType {
			get { return new EventorTypeStep(true, Path.Add("outE('EventorUsesEventorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorPrecisionStep UsesEventorPrecision {
			get { return new EventorPrecisionStep(true, Path.Add("outE('EventorUsesEventorPrecision')")); }
		}

	}

	/*================================================================================================*/
	public partial class EventorTypeStep : PathDomainStep<FabEventorType>,
			IInRootContains, IInEventorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InEventorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public EventorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "EventorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "ineventorlistuses": return InEventorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsEventorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorStep InEventorListUses {
			get { return new EventorStep(false, Path.Add("inE('EventorUsesEventorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class EventorPrecisionStep : PathDomainStep<FabEventorPrecision>,
			IInRootContains, IInEventorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InEventorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public EventorPrecisionStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "EventorPrecisionId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "ineventorlistuses": return InEventorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsEventorPrecision')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public EventorStep InEventorListUses {
			get { return new EventorStep(false, Path.Add("inE('EventorUsesEventorPrecision')")); }
		}

	}

	/*================================================================================================*/
	public partial class IdentorStep : PathDomainStep<FabIdentor>,
			IInRootContains, IInFactorUsesList, IUsesIdentorType {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesIdentorType" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public IdentorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "IdentorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "usesidentortype": return UsesIdentorType;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsIdentor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesIdentor')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public IdentorTypeStep UsesIdentorType {
			get { return new IdentorTypeStep(true, Path.Add("outE('IdentorUsesIdentorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class IdentorTypeStep : PathDomainStep<FabIdentorType>,
			IInRootContains, IInIdentorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InIdentorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public IdentorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "IdentorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inidentorlistuses": return InIdentorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsIdentorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public IdentorStep InIdentorListUses {
			get { return new IdentorStep(false, Path.Add("inE('IdentorUsesIdentorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class LocatorStep : PathDomainStep<FabLocator>,
			IInRootContains, IInFactorUsesList, IUsesLocatorType {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesLocatorType" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public LocatorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "LocatorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "useslocatortype": return UsesLocatorType;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsLocator')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesLocator')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LocatorTypeStep UsesLocatorType {
			get { return new LocatorTypeStep(true, Path.Add("outE('LocatorUsesLocatorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class LocatorTypeStep : PathDomainStep<FabLocatorType>,
			IInRootContains, IInLocatorUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InLocatorListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public LocatorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "LocatorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "inlocatorlistuses": return InLocatorListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsLocatorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public LocatorStep InLocatorListUses {
			get { return new LocatorStep(false, Path.Add("inE('LocatorUsesLocatorType')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorStep : PathDomainStep<FabVector>,
			IInRootContains, IInFactorUsesList, IUsesAxisArtifact, IUsesVectorType, IUsesVectorUnit, IUsesVectorUnitPrefix {
	
		private static readonly string[] AvailSteps = new string[] { "/InFactorListUses", "/UsesAxisArtifact", "/UsesVectorType", "/UsesVectorUnit", "/UsesVectorUnitPrefix" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "infactorlistuses": return InFactorListUses;
				case "usesaxisartifact": return UsesAxisArtifact;
				case "usesvectortype": return UsesVectorType;
				case "usesvectorunit": return UsesVectorUnit;
				case "usesvectorunitprefix": return UsesVectorUnitPrefix;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public FactorStep InFactorListUses {
			get { return new FactorStep(false, Path.Add("inE('FactorUsesVector')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public ArtifactStep UsesAxisArtifact {
			get { return new ArtifactStep(true, Path.Add("outE('VectorUsesAxisArtifact')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorTypeStep UsesVectorType {
			get { return new VectorTypeStep(true, Path.Add("outE('VectorUsesVectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitStep UsesVectorUnit {
			get { return new VectorUnitStep(true, Path.Add("outE('VectorUsesVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitPrefixStep UsesVectorUnitPrefix {
			get { return new VectorUnitPrefixStep(true, Path.Add("outE('VectorUsesVectorUnitPrefix')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorTypeStep : PathDomainStep<FabVectorType>,
			IInRootContains, IInVectorUsesList, IUsesVectorRange {
	
		private static readonly string[] AvailSteps = new string[] { "/InVectorListUses", "/UsesVectorRange" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorTypeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorTypeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "invectorlistuses": return InVectorListUses;
				case "usesvectorrange": return UsesVectorRange;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep InVectorListUses {
			get { return new VectorStep(false, Path.Add("inE('VectorUsesVectorType')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeStep UsesVectorRange {
			get { return new VectorRangeStep(true, Path.Add("outE('VectorTypeUsesVectorRange')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorRangeStep : PathDomainStep<FabVectorRange>,
			IInRootContains, IInVectorTypeUsesList, IUsesVectorRangeLevelList {
	
		private static readonly string[] AvailSteps = new string[] { "/InVectorTypeListUses", "/UsesVectorRangeLevelList" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorRangeId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "invectortypelistuses": return InVectorTypeListUses;
				case "usesvectorrangelevellist": return UsesVectorRangeLevelList;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorRange')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorTypeStep InVectorTypeListUses {
			get { return new VectorTypeStep(false, Path.Add("inE('VectorTypeUsesVectorRange')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeLevelStep UsesVectorRangeLevelList {
			get { return new VectorRangeLevelStep(true, Path.Add("outE('VectorRangeUsesVectorRangeLevel')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorRangeLevelStep : PathDomainStep<FabVectorRangeLevel>,
			IInRootContains, IInVectorRangeUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InVectorRangeListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeLevelStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorRangeLevelId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "invectorrangelistuses": return InVectorRangeListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorRangeLevel')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorRangeStep InVectorRangeListUses {
			get { return new VectorRangeStep(false, Path.Add("inE('VectorRangeUsesVectorRangeLevel')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorUnitStep : PathDomainStep<FabVectorUnit>,
			IInRootContains, IInVectorUsesList, IInVectorUnitDerivedDefinesList, IInVectorUnitDerivedRaisesToExpList {
	
		private static readonly string[] AvailSteps = new string[] { "/InVectorListUses", "/InVectorUnitDerivedListDefines", "/InVectorUnitDerivedListRaisesToExp" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorUnitId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "invectorlistuses": return InVectorListUses;
				case "invectorunitderivedlistdefines": return InVectorUnitDerivedListDefines;
				case "invectorunitderivedlistraisestoexp": return InVectorUnitDerivedListRaisesToExp;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep InVectorListUses {
			get { return new VectorStep(false, Path.Add("inE('VectorUsesVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitDerivedStep InVectorUnitDerivedListDefines {
			get { return new VectorUnitDerivedStep(false, Path.Add("inE('VectorUnitDerivedDefinesVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitDerivedStep InVectorUnitDerivedListRaisesToExp {
			get { return new VectorUnitDerivedStep(false, Path.Add("inE('VectorUnitDerivedRaisesToExpVectorUnit')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorUnitPrefixStep : PathDomainStep<FabVectorUnitPrefix>,
			IInRootContains, IInVectorUsesList, IInVectorUnitDerivedUsesList {
	
		private static readonly string[] AvailSteps = new string[] { "/InVectorListUses", "/InVectorUnitDerivedListUses" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitPrefixStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorUnitPrefixId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "invectorlistuses": return InVectorListUses;
				case "invectorunitderivedlistuses": return InVectorUnitDerivedListUses;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorUnitPrefix')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorStep InVectorListUses {
			get { return new VectorStep(false, Path.Add("inE('VectorUsesVectorUnitPrefix')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitDerivedStep InVectorUnitDerivedListUses {
			get { return new VectorUnitDerivedStep(false, Path.Add("inE('VectorUnitDerivedUsesVectorUnitPrefix')")); }
		}

	}

	/*================================================================================================*/
	public partial class VectorUnitDerivedStep : PathDomainStep<FabVectorUnitDerived>,
			IInRootContains, IDefinesVectorUnit, IRaisesToExpVectorUnit, IUsesVectorUnitPrefix {
	
		private static readonly string[] AvailSteps = new string[] { "/DefinesVectorUnit", "/RaisesToExpVectorUnit", "/UsesVectorUnitPrefix" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitDerivedStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "VectorUnitDerivedId"; } }
		protected override bool TypeIdIsLong { get { return false; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "definesvectorunit": return DefinesVectorUnit;
				case "raisestoexpvectorunit": return RaisesToExpVectorUnit;
				case "usesvectorunitprefix": return UsesVectorUnitPrefix;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsVectorUnitDerived')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitStep DefinesVectorUnit {
			get { return new VectorUnitStep(true, Path.Add("outE('VectorUnitDerivedDefinesVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitStep RaisesToExpVectorUnit {
			get { return new VectorUnitStep(true, Path.Add("outE('VectorUnitDerivedRaisesToExpVectorUnit')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public VectorUnitPrefixStep UsesVectorUnitPrefix {
			get { return new VectorUnitPrefixStep(true, Path.Add("outE('VectorUnitDerivedUsesVectorUnitPrefix')")); }
		}

	}

	/*================================================================================================*/
	public partial class OauthAccessStep : PathDomainStep<FabOauthAccess>,
			IInRootContains, IUsesApp, IUsesUser {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesApp", "/UsesUser" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public OauthAccessStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "OauthAccessId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usesapp": return UsesApp;
				case "usesuser": return UsesUser;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsOauthAccess')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep UsesApp {
			get { return new AppStep(true, Path.Add("outE('OauthAccessUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep UsesUser {
			get { return new UserStep(true, Path.Add("outE('OauthAccessUsesUser')")); }
		}

	}

	/*================================================================================================*/
	public partial class OauthDomainStep : PathDomainStep<FabOauthDomain>,
			IInRootContains, IUsesApp {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesApp" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public OauthDomainStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "OauthDomainId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usesapp": return UsesApp;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsOauthDomain')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep UsesApp {
			get { return new AppStep(true, Path.Add("outE('OauthDomainUsesApp')")); }
		}

	}

	/*================================================================================================*/
	public partial class OauthGrantStep : PathDomainStep<FabOauthGrant>,
			IInRootContains, IUsesApp, IUsesUser {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesApp", "/UsesUser" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public OauthGrantStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "OauthGrantId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usesapp": return UsesApp;
				case "usesuser": return UsesUser;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsOauthGrant')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep UsesApp {
			get { return new AppStep(true, Path.Add("outE('OauthGrantUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep UsesUser {
			get { return new UserStep(true, Path.Add("outE('OauthGrantUsesUser')")); }
		}

	}

	/*================================================================================================*/
	public partial class OauthScopeStep : PathDomainStep<FabOauthScope>,
			IInRootContains, IUsesApp, IUsesUser {
	
		private static readonly string[] AvailSteps = new string[] { "/UsesApp", "/UsesUser" };


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public OauthScopeStep(bool pIsToNode, Path pPath) {
			string q;

			if ( pPath.Script.Length == 0 ) {
				q = "g.v(0)";
			}
			else {
				q = (pIsToNode ? "inV" : "outV");
			}

			Path = pPath.Add(q);
		}

		/*--------------------------------------------------------------------------------------------*/
		protected override string TypeIdName { get { return "OauthScopeId"; } }
		protected override bool TypeIdIsLong { get { return true; } }
		
		/*--------------------------------------------------------------------------------------------*/
		public override string[] AvailableSteps {
			get {
				string[] baseSteps = base.AvailableSteps;
				var mergeSteps = new string[baseSteps.Length+AvailSteps.Length];
				base.AvailableSteps.CopyTo(mergeSteps, 0);
				AvailSteps.CopyTo(mergeSteps, baseSteps.Length);
				return mergeSteps;
			}
		}
		
		/*--------------------------------------------------------------------------------------------*/
		protected override IPathStep GetStepByString(string pName) {
			switch ( pName ) {
				case "inrootcontains": return InRootContains;
				case "usesapp": return UsesApp;
				case "usesuser": return UsesUser;
			}

			return base.GetStepByString(pName);
		}


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public RootStep InRootContains {
			get { return new RootStep(false, Path.Add("inE('RootContainsOauthScope')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public AppStep UsesApp {
			get { return new AppStep(true, Path.Add("outE('OauthScopeUsesApp')")); }
		}

		/*--------------------------------------------------------------------------------------------*/
		public UserStep UsesUser {
			get { return new UserStep(true, Path.Add("outE('OauthScopeUsesUser')")); }
		}

	}

}