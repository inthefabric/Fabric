<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)../Packages/Weaver.1.0.0/Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

namespace Fabric.Db.Data.Setups {

	/*================================================================================================*/
	public static partial class SetupIndexes {


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void SetupAll(DataSet pSet) {

			//VERTICES
<#
var schema = new Schema();
IList<WeaverNodeSchema> nodes = schema.Nodes;
int groupId = 2;
var propNameMap = new Dictionary<string, SchemaHelperProp>();
var propSkipMap = new Dictionary<string, bool>();

foreach ( WeaverNodeSchema node in nodes ) {
	//if ( node.IsAbstract ) { continue; }
#>

			//<#= node.Name #>
			pSet.AddIndexQuery(BuildGroup("<#= node.DbName #>", <#= groupId++ #>));
<#

	foreach ( WeaverPropSchema ps in node.Props ) {
		FabricPropSchema prop = (FabricPropSchema)ps;
		string titanType = SchemaHelperProp.GetTitanTypeName(prop.Type);
		bool index = (prop.IsPrimaryKey == true || prop.IndexWithElasticSearch || prop.Name == "FabType");
		bool elastic = (prop.IndexWithElasticSearch || prop.IsTimestamp == true);
#>
			pSet.AddIndexQuery(BuildKey("<#= node.DbName #>", "<#= prop.DbName #>", "<#= titanType #>", <#= index.ToString().ToLower() #>, <#= elastic.ToString().ToLower() #>));
<#
	} //end prop loop
} //end node loop
#>
	
			//EDGES
<#
IList<string> rels = SchemaHelper.GetRels();

foreach ( string name in rels ) {
	SchemaHelperRel rel = SchemaHelper.GetRel(name);
	SchemaHelperNode from = SchemaHelper.GetNode(rel.FromNodeName);
	SchemaHelperNode to = SchemaHelper.GetNode(rel.ToNodeName);
	IList<SchemaHelperProp> fromProps = from.GetProps(false);
	IList<SchemaHelperProp> toProps = to.GetProps(false);
	SchemaHelperNodeRel fromRel = new SchemaHelperNodeRel(from, rel.RelSchema);
	SchemaHelperNodeRel toRel = new SchemaHelperNodeRel(to, rel.RelSchema);
	string outUnique = (!fromRel.IsMany).ToString().ToLower();
	string inUnique = (!toRel.IsMany).ToString().ToLower();
	var keys = new List<string>();
	var sigs = new List<string>();

	var props = new List<FabricPropSchema>();
	foreach ( SchemaHelperProp hp in fromProps ) { props.Add((FabricPropSchema)hp.PropSchema); }
	foreach ( SchemaHelperProp hp in toProps ) { props.Add((FabricPropSchema)hp.PropSchema); }

	foreach ( FabricPropSchema prop in props ) {
		string key = prop.DbName;

		if ( propSkipMap.ContainsKey(key) ) {
			continue;
		}

		sigs.Add(key);

		if ( prop.IsPrimaryKey == true || prop.EnumName != null ) {
			keys.Add(key);
		}
	}
#>

			//<#= rel.RelName #>
			pSet.AddIndexQuery(BuildLabel("<#= rel.RelSchema.DbName #>", <#= inUnique #>, <#= outUnique #>, new [] {
				"<#= string.Join("\",\r\n\t\t\t\t\"", sigs) #>"
			}));
<#
} //end rel names loop
#>
		}

	}

}