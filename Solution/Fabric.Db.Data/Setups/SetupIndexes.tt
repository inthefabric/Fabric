<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)../Packages/Weaver/Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

namespace Fabric.Db.Data.Setups {

	/*================================================================================================*/
	public static partial class SetupIndexes {


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void SetupAll(DataSet pSet) {

			//VERTICES
<#
var schema = new Schema();
IList<WeaverVertexSchema> nodes = schema.Nodes;
int groupId = 2;
var propNameMap = new Dictionary<string, SchemaHelperProp>();
var propSkipMap = new Dictionary<string, bool>();

foreach ( WeaverVertexSchema node in nodes ) {
	//if ( node.IsAbstract ) { continue; }
#>

			//<#= node.Name #>
			pSet.AddIndexQuery(BuildGroup("<#= node.DbName #>", <#= groupId++ #>));
<#

	foreach ( WeaverPropSchema ps in node.Props ) {
		FabricPropSchema prop = (FabricPropSchema)ps;
		string titanType = SchemaHelperProp.GetTitanTypeName(prop.Type);
		bool index = (prop.IsPrimaryKey == true || prop.IndexWithTitan == true);
		bool elastic = (prop.IndexWithElasticSearch == true);
#>
			pSet.AddIndexQuery(BuildKey("<#= node.DbName #>", "<#= prop.DbName #>", "<#= titanType #>", <#= index.ToString().ToLower() #>, <#= elastic.ToString().ToLower() #>));
<#
	} //end prop loop
} //end node loop
#>
	
			//EDGES
<#
IList<string> rels = SchemaHelper.GetEdges();

foreach ( string name in rels ) {
	SchemaHelperRel rel = SchemaHelper.GetEdge(name);
	SchemaHelperNode from = SchemaHelper.GetNode(rel.OutVertexName);
	SchemaHelperNode to = SchemaHelper.GetNode(rel.InVertexName);
	IList<SchemaHelperProp> fromProps = from.GetProps(false);
	IList<SchemaHelperProp> toProps = to.GetProps(false);
	SchemaHelperNodeRel fromRel = new SchemaHelperNodeRel(from, rel.RelSchema);
	SchemaHelperNodeRel toRel = new SchemaHelperNodeRel(to, rel.RelSchema);
	string outUnique = (!fromRel.IsMany).ToString().ToLower();
	string inUnique = (!toRel.IsMany).ToString().ToLower();
	var keys = new List<string>();
	var sigs = new List<string>();

	var props = new List<SchemaHelperProp>();
	foreach ( SchemaHelperProp hp in fromProps ) { props.Add(hp); }
	foreach ( SchemaHelperProp hp in toProps ) { props.Add(hp); }

	foreach ( SchemaHelperProp hp in props ) {
		FabricPropSchema prop = (FabricPropSchema)hp.PropSchema;
		string key = prop.DbName;

		if ( propSkipMap.ContainsKey(key) ) {
			continue;
		}

		if ( hp.UseVertexCentricIndexForRel(rel) ) {
			keys.Add(key);
		}
		else {
			sigs.Add(key);
		}
	}
#>

			//<#= rel.EdgeName #>
			pSet.AddIndexQuery(BuildLabel("<#= rel.RelSchema.DbName #>", <#= inUnique #>, <#= outUnique #>, 
				new [] {
					"<#= string.Join("\",\r\n\t\t\t\t\t\"", keys) #>"
				},
				new [] {
					"<#= string.Join("\",\r\n\t\t\t\t\t\"", sigs) #>"
				}
			));
<#
} //end rel names loop
#>
		}

	}

}