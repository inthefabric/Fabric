<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)../Packages/Weaver/Weaver.Core.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Domain.Meta/bin/Debug/Fabric.Domain.Meta.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Fabric.Domain.Meta" #>
<#@ import namespace="Weaver.Core.Schema" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

namespace Fabric.Db.Data.Setups {

	/*================================================================================================*/
	public static partial class SetupIndexes {


		////////////////////////////////////////////////////////////////////////////////////////////////
		/*--------------------------------------------------------------------------------------------*/
		public static void SetupAll(DataSet pSet) {

			//VERTICES
<#
var schema = new Schema();
IList<WeaverVertexSchema> verts = schema.Vertices;
int groupId = 2;
var propNameMap = new Dictionary<string, SchemaHelperProp>();
var propSkipMap = new Dictionary<string, bool>();

foreach ( WeaverVertexSchema vertex in verts ) {
	//if ( vertex.IsAbstract ) { continue; }
#>

			//<#= vertex.Name #>
			pSet.AddIndexQuery(BuildGroup("<#= vertex.DbName #>", <#= groupId++ #>));
<#

	foreach ( WeaverPropSchema ps in vertex.Props ) {
		FabricPropSchema prop = (FabricPropSchema)ps;
		string titanType = SchemaHelperProp.GetTitanTypeName(prop.Type);
		bool index = (prop.IsPrimaryKey == true || prop.IndexWithTitan == true);
		bool elastic = (prop.IndexWithElasticSearch == true);
#>
			pSet.AddIndexQuery(BuildKey("<#= vertex.DbName #>", "<#= prop.DbName #>", "<#= titanType #>", <#= index.ToString().ToLower() #>, <#= elastic.ToString().ToLower() #>));
<#
	} //end prop loop
} //end vertex loop
#>
	
			//EDGES
<#
IList<string> edges = SchemaHelper.GetEdges();

foreach ( string name in edges ) {
	SchemaHelperEdge edge = SchemaHelper.GetEdge(name);
	SchemaHelperVertex from = SchemaHelper.GetVertex(edge.OutVertexName);
	SchemaHelperVertex to = SchemaHelper.GetVertex(edge.InVertexName);
	IList<SchemaHelperProp> fromProps = from.GetProps(false);
	IList<SchemaHelperProp> toProps = to.GetProps(false);
	SchemaHelperVertexEdge fromEdge = new SchemaHelperVertexEdge(from, edge.EdgeSchema);
	SchemaHelperVertexEdge toEdge = new SchemaHelperVertexEdge(to, edge.EdgeSchema);
	string outUnique = (!fromEdge.IsMany).ToString().ToLower();
	string inUnique = (!toEdge.IsMany).ToString().ToLower();
	var keys = new List<string>();
	var sigs = new List<string>();

	var props = new List<SchemaHelperProp>();
	foreach ( SchemaHelperProp hp in fromProps ) { props.Add(hp); }
	foreach ( SchemaHelperProp hp in toProps ) { props.Add(hp); }

	foreach ( SchemaHelperProp hp in props ) {
		FabricPropSchema prop = (FabricPropSchema)hp.PropSchema;
		string key = prop.DbName;

		if ( propSkipMap.ContainsKey(key) ) {
			continue;
		}

		if ( hp.UseVertexCentricIndexForEdge(edge) ) {
			keys.Add(key);
		}
		else {
			sigs.Add(key);
		}
	}
#>

			//<#= edge.EdgeName #>
			pSet.AddIndexQuery(BuildLabel("<#= edge.EdgeSchema.DbName #>", <#= inUnique #>, <#= outUnique #>, 
				new [] {
					"<#= string.Join("\",\r\n\t\t\t\t\t\"", keys) #>"
				},
				new [] {
					"<#= string.Join("\",\r\n\t\t\t\t\t\"", sigs) #>"
				}
			));
<#
} //end edge names loop
#>
		}

	}

}