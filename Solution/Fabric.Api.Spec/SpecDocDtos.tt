<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)..\Packages\Weaver.1.0.0\Weaver.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Infrastructure\bin\Debug\Fabric.Infrastructure.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Api.Dto\bin\Debug\Fabric.Api.Dto.dll" #>
<#@ assembly name="$(SolutionDir)Fabric.Api.Paths\bin\Debug\Fabric.Api.Paths.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Fabric.Api.Dto" #>
<#@ import namespace="Fabric.Api.Paths.Steps.Functions" #>
<#@ import namespace="Fabric.Infrastructure.Domain" #>
<#@ import namespace="Weaver.Items" #>
<#@ import namespace="Weaver.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// GENERATED CODE
// Changes made to this source file will be overwritten
// Generated on <#= DateTime.Now.ToString() #>

using System.Collections.Generic;
using Fabric.Api.Dto.Spec;

namespace Fabric.Api.Spec {

	/*================================================================================================*/
	public partial class SpecDoc {
	
		/*--------------------------------------------------------------------------------------------*/
		public List<FabSpecDto> BuildDtoList() {
			var list = new List<FabSpecDto>();
			
			FabSpecDto dto;
			FabSpecDtoProp p;
			FabSpecDtoLink l;

<#
IList<string> nodes = SchemaHelper.GetNodes();
string fabApiDtoNamespace = typeof(FabNode).AssemblyQualifiedName;

foreach ( string name in nodes ) {
	SchemaHelperNode hn = SchemaHelper.GetNode(name);
	WeaverNodeSchema node = hn.NodeSchema;
	if ( node.IsInternal ) { continue; }

	string baseNode = "Fab"+(hn.HasParentClass ? node.BaseNode.Name : "Node");
#>
			////

			dto = new FabSpecDto();
			dto.Name = "Fab<#= node.Name #>";
			dto.Extends = "<#= baseNode #>";
			dto.Description = GetDtoText("<#= node.Name #>");
			list.Add(dto);
	
<#
	IList<SchemaHelperProp> props = hn.GetProps(true);

	foreach ( SchemaHelperProp hp in props ) {
		WeaverPropSchema prop = hp.PropSchema;
		string propType = hp.TypeName;
		string propName = prop.Name;
		string propItems = "";
		string lineEnd = "\r\n\t\t\t\t";
		
		if ( prop.IsCaseInsensitive != null ) {
			propItems += "p.IsCaseInsensitive = "+prop.IsCaseInsensitive.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsNullable != null ) {
			propItems += "p.IsNullable = "+prop.IsNullable.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsPrimaryKey != null ) {
			propItems += "p.IsPrimaryKey = "+prop.IsPrimaryKey.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.IsTimestamp != null ) {
			propItems += "p.IsTimestamp = "+prop.IsTimestamp.ToString().ToLower()+";"+lineEnd;
		}
		
		if ( prop.IsUnique != null ) {
			propItems += "p.IsUnique = "+prop.IsUnique.ToString().ToLower()+";"+lineEnd;
		}

		if ( prop.Len != null ) {
			propItems += "p.Len = "+prop.Len+";"+lineEnd;
		}

		if ( prop.LenMax != null ) {
			propItems += "p.LenMax = "+prop.LenMax+";"+lineEnd;
		}

		if ( prop.LenMin != null ) {
			propItems += "p.LenMin = "+prop.LenMin+";"+lineEnd;
		}

		if ( prop.ValidRegex != null ) {
			propItems += "p.ValidRegex = @\""+prop.ValidRegex.Replace("\"", "\"\"")+"\";"+lineEnd;
		}

		string resxDesc = (prop.IsPrimaryKey == true ? "Object_TypeId" : node.Name+"_"+propName);

#>
				p = new FabSpecDtoProp();
				p.Name = "<#= propName #>";
				p.Type = "<#= propType #>";
				p.Description = GetDtoPropText("<#= resxDesc #>");
				<#= propItems #>dto.PropertyList.Add(p);

<#
	} //end prop loop
	
	IList<SchemaHelperNodeRel> nodeRels = hn.GetRels(true);

	foreach ( SchemaHelperNodeRel hr in nodeRels ) {
		if ( node.Name != "Root" && hr.FromNodeName == "Root" ) { continue; }
#>
					l = new FabSpecDtoLink();
					l.Name = "<#= hr.RelPropName #>";
					l.IsOutgoing = <#= hr.IsOutgoing.ToString().ToLower() #>;
					l.FromDto = "Fab<#= hr.FromNodeName #>";
					l.FromDtoConn = "<#= hr.RelSchema.FromNodeConn+"" #>";
					l.Verb = "<#= hr.RelName #>";
					l.ToDto = "Fab<#= hr.ToNodeName #>";
					l.ToDtoConn = "<#= hr.RelSchema.ToNodeConn+"" #>";
					dto.LinkList.Add(l);

<#
	} //end rel loop

	if ( !node.IsAbstract ) {
		string dtoAqn = fabApiDtoNamespace.Replace("FabNode", "Fab"+node.Name);
		Type dtoType = Type.GetType(dtoAqn);
		List<string> availFuncs = FuncRegistry.GetAvailableFuncs(dtoType, true);
		
		foreach ( string funcUri in availFuncs ) {
#>
						dto.FunctionList.Add("<#= funcUri.Substring(1) #>");

<#
		} //end func loop
	} //end IsAbstract check

} // end node loop
#>
			return list;
		}

	}

}